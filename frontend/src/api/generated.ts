/**
 * Generated by orval v7.11.2 üç∫
 * Do not edit manually.
 * Blog Backend API
 * A scalable blog backend built with FastAPI and SQLModel
 * OpenAPI spec version: 1.0.0
 */
import useSwr from 'swr';
import type {
  Arguments,
  Key,
  SWRConfiguration
} from 'swr';

import useSWRMutation from 'swr/mutation';
import type {
  SWRMutationConfiguration
} from 'swr/mutation';

import { customInstance } from './axios';
/**
 * Associated post ID
 */
export type BodyUploadFilesUploadPostPostId = string | null;

export interface BodyUploadFilesUploadPost {
  files: Blob[];
  /** Associated post ID */
  post_id?: BodyUploadFilesUploadPostPostId;
}

export type CategoryCreateDescription = string | null;

/**
 * Model for category creation.
 */
export interface CategoryCreate {
  /** @maxLength 100 */
  name: string;
  /** @maxLength 100 */
  slug: string;
  description?: CategoryCreateDescription;
}

export type CategoryReadDescription = string | null;

/**
 * Model for category response.
 */
export interface CategoryRead {
  id: number;
  name: string;
  slug: string;
  description: CategoryReadDescription;
}

export type CategoryUpdateName = string | null;

export type CategoryUpdateSlug = string | null;

export type CategoryUpdateDescription = string | null;

/**
 * Model for category updates.
 */
export interface CategoryUpdate {
  name?: CategoryUpdateName;
  slug?: CategoryUpdateSlug;
  description?: CategoryUpdateDescription;
}

export type CommentCreateParentCommentId = string | null;

export type CommentCreateAuthorName = string | null;

export type CommentCreateAuthorEmail = string | null;

export type CommentCreateAuthorUrl = string | null;

/**
 * Model for comment creation.
 */
export interface CommentCreate {
  post_id: string;
  content: string;
  parent_comment_id?: CommentCreateParentCommentId;
  author_name?: CommentCreateAuthorName;
  author_email?: CommentCreateAuthorEmail;
  author_url?: CommentCreateAuthorUrl;
}

export type CommentReadAuthorId = string | null;

export type CommentReadAuthorName = string | null;

export type CommentReadAuthorEmail = string | null;

export type CommentReadAuthorUrl = string | null;

export type CommentReadParentCommentId = string | null;

/**
 * Model for comment response.
 */
export interface CommentRead {
  id: string;
  post_id: string;
  author_id: CommentReadAuthorId;
  author_name: CommentReadAuthorName;
  author_email: CommentReadAuthorEmail;
  author_url: CommentReadAuthorUrl;
  content: string;
  parent_comment_id: CommentReadParentCommentId;
  status: CommentStatus;
  created_at: string;
  updated_at: string;
}

/**
 * Comment status enumeration.
 */
export type CommentStatus = typeof CommentStatus[keyof typeof CommentStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CommentStatus = {
  pending: 'pending',
  approved: 'approved',
  rejected: 'rejected',
  spam: 'spam',
} as const;

export type CommentUpdateContent = string | null;

export type CommentUpdateStatus = CommentStatus | null;

/**
 * Model for comment updates.
 */
export interface CommentUpdate {
  content?: CommentUpdateContent;
  status?: CommentUpdateStatus;
}

export type ExtensionInfoVersion = string | null;

export type ExtensionInfoConfigAnyOf = { [key: string]: unknown };

export type ExtensionInfoConfig = ExtensionInfoConfigAnyOf | null;

/**
 * Model for extension information.
 */
export interface ExtensionInfo {
  id: number;
  name: string;
  slug: string;
  version: ExtensionInfoVersion;
  is_active: boolean;
  config: ExtensionInfoConfig;
}

/**
 * Model for extensions list response.
 */
export interface ExtensionsResponse {
  extensions: ExtensionInfo[];
}

export interface HTTPValidationError {
  detail?: ValidationError[];
}

/**
 * Model for like creation.
 */
export interface LikeCreate {
  post_id: string;
}

export type LikeReadUserId = string | null;

/**
 * Model for like response.
 */
export interface LikeRead {
  id: string;
  post_id: string;
  user_id: LikeReadUserId;
  created_at: string;
}

export type PostCreateTitle = string | null;

export type PostCreateContent = string | null;

export type PostCreateMarkdownContent = string | null;

export type PostCreateMediaUrl = string | null;

export type PostCreateLinkUrl = string | null;

export type PostCreateMediaType = string | null;

export type PostCreateQuoteSource = string | null;

/**
 * Model for post creation.
 */
export interface PostCreate {
  /** @maxLength 50 */
  feather_type: string;
  /** @maxLength 255 */
  slug: string;
  title?: PostCreateTitle;
  status?: PostStatus;
  is_private?: boolean;
  content?: PostCreateContent;
  markdown_content?: PostCreateMarkdownContent;
  media_url?: PostCreateMediaUrl;
  link_url?: PostCreateLinkUrl;
  media_type?: PostCreateMediaType;
  quote_source?: PostCreateQuoteSource;
}

export type PostFileId = string | null;

export type PostFilePostId = string | null;

export type PostFileFileType = string | null;

export type PostFileFileSize = number | null;

export type PostFileDescription = string | null;

/**
 * Post file model - for file attachments.
 */
export interface PostFile {
  id?: PostFileId;
  post_id?: PostFilePostId;
  /** @maxLength 255 */
  file_url: string;
  /** @maxLength 255 */
  filename: string;
  file_type?: PostFileFileType;
  file_size?: PostFileFileSize;
  description?: PostFileDescription;
  uploaded_at?: string;
}

export type PostFileReadPostId = string | null;

export type PostFileReadFilename = string | null;

export type PostFileReadFilePath = string | null;

export type PostFileReadMimeType = string | null;

export type PostFileReadFileSize = number | null;

export type PostFileReadDescription = string | null;

export type PostFileReadCreatedAt = string | null;

export type PostFileReadUpdatedAt = string | null;

/**
 * Model for file response.
 */
export interface PostFileRead {
  id: string;
  post_id: PostFileReadPostId;
  filename: PostFileReadFilename;
  file_path: PostFileReadFilePath;
  mime_type: PostFileReadMimeType;
  file_size: PostFileReadFileSize;
  description: PostFileReadDescription;
  created_at: PostFileReadCreatedAt;
  updated_at: PostFileReadUpdatedAt;
}

export type PostReadTitle = string | null;

export type PostReadPublishedAt = string | null;

export type PostReadCategoriesItem = { [key: string]: unknown };

export type PostReadTagsItem = { [key: string]: unknown };

export type PostReadContent = string | null;

export type PostReadExcerpt = string | null;

export type PostReadMediaUrl = string | null;

export type PostReadMediaType = string | null;

export type PostReadQuoteSource = string | null;

export type PostReadLinkUrl = string | null;

/**
 * Model for post response.
 */
export interface PostRead {
  id: string;
  author_id: string;
  author_name: string;
  feather_type: string;
  slug: string;
  title: PostReadTitle;
  status: PostStatus;
  published_at: PostReadPublishedAt;
  is_private: boolean;
  view_count: number;
  created_at: string;
  updated_at: string;
  categories?: PostReadCategoriesItem[];
  tags?: PostReadTagsItem[];
  likes_count?: number;
  content?: PostReadContent;
  excerpt?: PostReadExcerpt;
  media_url?: PostReadMediaUrl;
  media_type?: PostReadMediaType;
  quote_source?: PostReadQuoteSource;
  link_url?: PostReadLinkUrl;
}

/**
 * Post status enumeration.
 */
export type PostStatus = typeof PostStatus[keyof typeof PostStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PostStatus = {
  draft: 'draft',
  published: 'published',
  scheduled: 'scheduled',
  private: 'private',
} as const;

export type PostUpdateTitle = string | null;

export type PostUpdateStatus = PostStatus | null;

export type PostUpdateIsPrivate = boolean | null;

export type PostUpdateContent = string | null;

export type PostUpdateMarkdownContent = string | null;

/**
 * Model for post updates.
 */
export interface PostUpdate {
  title?: PostUpdateTitle;
  status?: PostUpdateStatus;
  is_private?: PostUpdateIsPrivate;
  content?: PostUpdateContent;
  markdown_content?: PostUpdateMarkdownContent;
}

export type SiteInfoResponseUser = UserRead | null;

export type SiteInfoResponseTheme = string | null;

export type SiteInfoResponseSettings = { [key: string]: unknown };

/**
 * Model for site information response.
 */
export interface SiteInfoResponse {
  user?: SiteInfoResponseUser;
  blog_title: string;
  blog_description: string;
  extensions: string[];
  theme: SiteInfoResponseTheme;
  settings: SiteInfoResponseSettings;
  features: string[];
}

/**
 * Model for tag creation.
 */
export interface TagCreate {
  /** @maxLength 100 */
  name: string;
  /** @maxLength 100 */
  slug: string;
}

/**
 * Model for tag response.
 */
export interface TagRead {
  id: number;
  name: string;
  slug: string;
}

export type ThemeReadVersion = string | null;

export type ThemeReadAuthor = string | null;

/**
 * Model for theme response.
 */
export interface ThemeRead {
  id: number;
  name: string;
  slug: string;
  version: ThemeReadVersion;
  author: ThemeReadAuthor;
  is_active: boolean;
}

export type UserCreateDisplayName = string | null;

export type UserCreateBio = string | null;

/**
 * Model for user creation.
 */
export interface UserCreate {
  /** @maxLength 50 */
  username: string;
  /** @maxLength 255 */
  email: string;
  /** @minLength 8 */
  password: string;
  display_name?: UserCreateDisplayName;
  bio?: UserCreateBio;
}

/**
 * Model for user login.
 */
export interface UserLogin {
  username: string;
  password: string;
}

export type UserReadDisplayName = string | null;

export type UserReadBio = string | null;

export type UserReadAvatarUrl = string | null;

/**
 * Model for user response (without sensitive data).
 */
export interface UserRead {
  id: string;
  username: string;
  email: string;
  display_name: UserReadDisplayName;
  bio: UserReadBio;
  avatar_url: UserReadAvatarUrl;
  created_at: string;
  updated_at: string;
}

export type UserUpdateDisplayName = string | null;

export type UserUpdateBio = string | null;

export type UserUpdateAvatarUrl = string | null;

export type UserUpdatePassword = string | null;

/**
 * Model for user updates.
 */
export interface UserUpdate {
  display_name?: UserUpdateDisplayName;
  bio?: UserUpdateBio;
  avatar_url?: UserUpdateAvatarUrl;
  password?: UserUpdatePassword;
}

export type ValidationErrorLocItem = string | number;

export interface ValidationError {
  loc: ValidationErrorLocItem[];
  msg: string;
  type: string;
}

export type ListUsersUsersGetParams = {
/**
 * @minimum 0
 */
skip?: number;
/**
 * @minimum 1
 * @maximum 100
 */
limit?: number;
};

export type ListPostsPostsGetParams = {
/**
 * Number of posts to skip
 * @minimum 0
 */
skip?: number;
/**
 * Number of posts to return
 * @minimum 1
 * @maximum 100
 */
limit?: number;
/**
 * Filter by category slug
 */
category?: string | null;
/**
 * Filter by tag slug
 */
tag?: string | null;
/**
 * Search in title and content
 */
search?: string | null;
/**
 * Filter by post status
 */
status?: string | null;
/**
 * Filter by author ID
 */
author_id?: string | null;
};

export type ListCategoriesCategoriesGetParams = {
/**
 * @minimum 0
 */
skip?: number;
/**
 * @minimum 1
 * @maximum 100
 */
limit?: number;
};

export type ListTagsTagsGetParams = {
/**
 * @minimum 0
 */
skip?: number;
/**
 * @minimum 1
 * @maximum 100
 */
limit?: number;
search?: string | null;
};

export type ListPostCommentsPostsPostIdCommentsGetParams = {
/**
 * @minimum 0
 */
skip?: number;
/**
 * @minimum 1
 * @maximum 100
 */
limit?: number;
};

export type ListPostLikesPostsPostIdLikesGetParams = {
/**
 * @minimum 0
 */
skip?: number;
/**
 * @minimum 1
 * @maximum 100
 */
limit?: number;
};

export type ListFilesUploadGetParams = {
/**
 * Filter by post ID
 */
post_id?: string | null;
/**
 * Number of files to skip
 * @minimum 0
 */
skip?: number;
/**
 * Number of files to return
 * @minimum 1
 * @maximum 100
 */
limit?: number;
};

export type GetExtensionsSiteExtensionsGetParams = {
active_only?: boolean;
};

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];


  
/**
 * Register a new user.
 * @summary Register
 */
export const registerAuthRegisterPost = (
    userCreate: UserCreate,
 options?: SecondParameter<typeof customInstance>) => {
    return customInstance<UserRead>(
    {url: `/auth/register`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: userCreate
    },
    options);
  }



export const getRegisterAuthRegisterPostMutationFetcher = ( options?: SecondParameter<typeof customInstance>) => {
  return (_: Key, { arg }: { arg: UserCreate }): Promise<UserRead> => {
    return registerAuthRegisterPost(arg, options);
  }
}
export const getRegisterAuthRegisterPostMutationKey = () => [`/auth/register`] as const;

export type RegisterAuthRegisterPostMutationResult = NonNullable<Awaited<ReturnType<typeof registerAuthRegisterPost>>>
export type RegisterAuthRegisterPostMutationError = HTTPValidationError

/**
 * @summary Register
 */
export const useRegisterAuthRegisterPost = <TError = HTTPValidationError>(
   options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof registerAuthRegisterPost>>, TError, Key, UserCreate, Awaited<ReturnType<typeof registerAuthRegisterPost>>> & { swrKey?: string }, request?: SecondParameter<typeof customInstance>}
) => {

  const {swr: swrOptions, request: requestOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getRegisterAuthRegisterPostMutationKey();
  const swrFn = getRegisterAuthRegisterPostMutationFetcher(requestOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * Login user and create session.
 * @summary Login
 */
export const loginAuthLoginPost = (
    userLogin: UserLogin,
 options?: SecondParameter<typeof customInstance>) => {
    return customInstance<unknown>(
    {url: `/auth/login`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: userLogin
    },
    options);
  }



export const getLoginAuthLoginPostMutationFetcher = ( options?: SecondParameter<typeof customInstance>) => {
  return (_: Key, { arg }: { arg: UserLogin }): Promise<unknown> => {
    return loginAuthLoginPost(arg, options);
  }
}
export const getLoginAuthLoginPostMutationKey = () => [`/auth/login`] as const;

export type LoginAuthLoginPostMutationResult = NonNullable<Awaited<ReturnType<typeof loginAuthLoginPost>>>
export type LoginAuthLoginPostMutationError = HTTPValidationError

/**
 * @summary Login
 */
export const useLoginAuthLoginPost = <TError = HTTPValidationError>(
   options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof loginAuthLoginPost>>, TError, Key, UserLogin, Awaited<ReturnType<typeof loginAuthLoginPost>>> & { swrKey?: string }, request?: SecondParameter<typeof customInstance>}
) => {

  const {swr: swrOptions, request: requestOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getLoginAuthLoginPostMutationKey();
  const swrFn = getLoginAuthLoginPostMutationFetcher(requestOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * Logout user and delete session.
 * @summary Logout
 */
export const logoutAuthLogoutPost = (
    
 options?: SecondParameter<typeof customInstance>) => {
    return customInstance<unknown>(
    {url: `/auth/logout`, method: 'POST'
    },
    options);
  }



export const getLogoutAuthLogoutPostMutationFetcher = ( options?: SecondParameter<typeof customInstance>) => {
  return (_: Key, __: { arg: Arguments }): Promise<unknown> => {
    return logoutAuthLogoutPost(options);
  }
}
export const getLogoutAuthLogoutPostMutationKey = () => [`/auth/logout`] as const;

export type LogoutAuthLogoutPostMutationResult = NonNullable<Awaited<ReturnType<typeof logoutAuthLogoutPost>>>
export type LogoutAuthLogoutPostMutationError = unknown

/**
 * @summary Logout
 */
export const useLogoutAuthLogoutPost = <TError = unknown>(
   options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof logoutAuthLogoutPost>>, TError, Key, Arguments, Awaited<ReturnType<typeof logoutAuthLogoutPost>>> & { swrKey?: string }, request?: SecondParameter<typeof customInstance>}
) => {

  const {swr: swrOptions, request: requestOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getLogoutAuthLogoutPostMutationKey();
  const swrFn = getLogoutAuthLogoutPostMutationFetcher(requestOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * Get current user information.
 * @summary Get Current User Info
 */
export const getCurrentUserInfoAuthMeGet = (
    
 options?: SecondParameter<typeof customInstance>) => {
    return customInstance<UserRead>(
    {url: `/auth/me`, method: 'GET'
    },
    options);
  }



export const getGetCurrentUserInfoAuthMeGetKey = () => [`/auth/me`] as const;

export type GetCurrentUserInfoAuthMeGetQueryResult = NonNullable<Awaited<ReturnType<typeof getCurrentUserInfoAuthMeGet>>>
export type GetCurrentUserInfoAuthMeGetQueryError = unknown

/**
 * @summary Get Current User Info
 */
export const useGetCurrentUserInfoAuthMeGet = <TError = unknown>(
   options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof getCurrentUserInfoAuthMeGet>>, TError> & { swrKey?: Key, enabled?: boolean }, request?: SecondParameter<typeof customInstance> }
) => {
  const {swr: swrOptions, request: requestOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getGetCurrentUserInfoAuthMeGetKey() : null);
  const swrFn = () => getCurrentUserInfoAuthMeGet(requestOptions)

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * Logout from all sessions.
 * @summary Logout All Sessions
 */
export const logoutAllSessionsAuthLogoutAllPost = (
    
 options?: SecondParameter<typeof customInstance>) => {
    return customInstance<unknown>(
    {url: `/auth/logout-all`, method: 'POST'
    },
    options);
  }



export const getLogoutAllSessionsAuthLogoutAllPostMutationFetcher = ( options?: SecondParameter<typeof customInstance>) => {
  return (_: Key, __: { arg: Arguments }): Promise<unknown> => {
    return logoutAllSessionsAuthLogoutAllPost(options);
  }
}
export const getLogoutAllSessionsAuthLogoutAllPostMutationKey = () => [`/auth/logout-all`] as const;

export type LogoutAllSessionsAuthLogoutAllPostMutationResult = NonNullable<Awaited<ReturnType<typeof logoutAllSessionsAuthLogoutAllPost>>>
export type LogoutAllSessionsAuthLogoutAllPostMutationError = unknown

/**
 * @summary Logout All Sessions
 */
export const useLogoutAllSessionsAuthLogoutAllPost = <TError = unknown>(
   options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof logoutAllSessionsAuthLogoutAllPost>>, TError, Key, Arguments, Awaited<ReturnType<typeof logoutAllSessionsAuthLogoutAllPost>>> & { swrKey?: string }, request?: SecondParameter<typeof customInstance>}
) => {

  const {swr: swrOptions, request: requestOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getLogoutAllSessionsAuthLogoutAllPostMutationKey();
  const swrFn = getLogoutAllSessionsAuthLogoutAllPostMutationFetcher(requestOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * List users with pagination.
 * @summary List Users
 */
export const listUsersUsersGet = (
    params?: ListUsersUsersGetParams,
 options?: SecondParameter<typeof customInstance>) => {
    return customInstance<UserRead[]>(
    {url: `/users/`, method: 'GET',
        params
    },
    options);
  }



export const getListUsersUsersGetKey = (params?: ListUsersUsersGetParams,) => [`/users/`, ...(params ? [params]: [])] as const;

export type ListUsersUsersGetQueryResult = NonNullable<Awaited<ReturnType<typeof listUsersUsersGet>>>
export type ListUsersUsersGetQueryError = HTTPValidationError

/**
 * @summary List Users
 */
export const useListUsersUsersGet = <TError = HTTPValidationError>(
  params?: ListUsersUsersGetParams, options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof listUsersUsersGet>>, TError> & { swrKey?: Key, enabled?: boolean }, request?: SecondParameter<typeof customInstance> }
) => {
  const {swr: swrOptions, request: requestOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getListUsersUsersGetKey(params) : null);
  const swrFn = () => listUsersUsersGet(params, requestOptions)

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * Get user by ID.
 * @summary Get User
 */
export const getUserUsersUserIdGet = (
    userId: string,
 options?: SecondParameter<typeof customInstance>) => {
    return customInstance<UserRead>(
    {url: `/users/${userId}`, method: 'GET'
    },
    options);
  }



export const getGetUserUsersUserIdGetKey = (userId: string,) => [`/users/${userId}`] as const;

export type GetUserUsersUserIdGetQueryResult = NonNullable<Awaited<ReturnType<typeof getUserUsersUserIdGet>>>
export type GetUserUsersUserIdGetQueryError = HTTPValidationError

/**
 * @summary Get User
 */
export const useGetUserUsersUserIdGet = <TError = HTTPValidationError>(
  userId: string, options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof getUserUsersUserIdGet>>, TError> & { swrKey?: Key, enabled?: boolean }, request?: SecondParameter<typeof customInstance> }
) => {
  const {swr: swrOptions, request: requestOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false && !!(userId)
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getGetUserUsersUserIdGetKey(userId) : null);
  const swrFn = () => getUserUsersUserIdGet(userId, requestOptions)

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * Update user (only own profile or admin).
 * @summary Update User
 */
export const updateUserUsersUserIdPut = (
    userId: string,
    userUpdate: UserUpdate,
 options?: SecondParameter<typeof customInstance>) => {
    return customInstance<UserRead>(
    {url: `/users/${userId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: userUpdate
    },
    options);
  }



export const getUpdateUserUsersUserIdPutMutationFetcher = (userId: string, options?: SecondParameter<typeof customInstance>) => {
  return (_: Key, { arg }: { arg: UserUpdate }): Promise<UserRead> => {
    return updateUserUsersUserIdPut(userId, arg, options);
  }
}
export const getUpdateUserUsersUserIdPutMutationKey = (userId: string,) => [`/users/${userId}`] as const;

export type UpdateUserUsersUserIdPutMutationResult = NonNullable<Awaited<ReturnType<typeof updateUserUsersUserIdPut>>>
export type UpdateUserUsersUserIdPutMutationError = HTTPValidationError

/**
 * @summary Update User
 */
export const useUpdateUserUsersUserIdPut = <TError = HTTPValidationError>(
  userId: string, options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof updateUserUsersUserIdPut>>, TError, Key, UserUpdate, Awaited<ReturnType<typeof updateUserUsersUserIdPut>>> & { swrKey?: string }, request?: SecondParameter<typeof customInstance>}
) => {

  const {swr: swrOptions, request: requestOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getUpdateUserUsersUserIdPutMutationKey(userId);
  const swrFn = getUpdateUserUsersUserIdPutMutationFetcher(userId, requestOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * Delete user (only own profile or admin).
 * @summary Delete User
 */
export const deleteUserUsersUserIdDelete = (
    userId: string,
 options?: SecondParameter<typeof customInstance>) => {
    return customInstance<unknown>(
    {url: `/users/${userId}`, method: 'DELETE'
    },
    options);
  }



export const getDeleteUserUsersUserIdDeleteMutationFetcher = (userId: string, options?: SecondParameter<typeof customInstance>) => {
  return (_: Key, __: { arg: Arguments }): Promise<unknown> => {
    return deleteUserUsersUserIdDelete(userId, options);
  }
}
export const getDeleteUserUsersUserIdDeleteMutationKey = (userId: string,) => [`/users/${userId}`] as const;

export type DeleteUserUsersUserIdDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof deleteUserUsersUserIdDelete>>>
export type DeleteUserUsersUserIdDeleteMutationError = HTTPValidationError

/**
 * @summary Delete User
 */
export const useDeleteUserUsersUserIdDelete = <TError = HTTPValidationError>(
  userId: string, options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof deleteUserUsersUserIdDelete>>, TError, Key, Arguments, Awaited<ReturnType<typeof deleteUserUsersUserIdDelete>>> & { swrKey?: string }, request?: SecondParameter<typeof customInstance>}
) => {

  const {swr: swrOptions, request: requestOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getDeleteUserUsersUserIdDeleteMutationKey(userId);
  const swrFn = getDeleteUserUsersUserIdDeleteMutationFetcher(userId, requestOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * List all posts with pagination and filtering.

Returns posts with joined categories, tags, likes, and view counts.
Private/draft posts are only visible to authenticated users.
 * @summary List Posts
 */
export const listPostsPostsGet = (
    params?: ListPostsPostsGetParams,
 options?: SecondParameter<typeof customInstance>) => {
    return customInstance<PostRead[]>(
    {url: `/posts`, method: 'GET',
        params
    },
    options);
  }



export const getListPostsPostsGetKey = (params?: ListPostsPostsGetParams,) => [`/posts`, ...(params ? [params]: [])] as const;

export type ListPostsPostsGetQueryResult = NonNullable<Awaited<ReturnType<typeof listPostsPostsGet>>>
export type ListPostsPostsGetQueryError = HTTPValidationError

/**
 * @summary List Posts
 */
export const useListPostsPostsGet = <TError = HTTPValidationError>(
  params?: ListPostsPostsGetParams, options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof listPostsPostsGet>>, TError> & { swrKey?: Key, enabled?: boolean }, request?: SecondParameter<typeof customInstance> }
) => {
  const {swr: swrOptions, request: requestOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getListPostsPostsGetKey(params) : null);
  const swrFn = () => listPostsPostsGet(params, requestOptions)

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * Create a new post.

Supports all post types: text, quote, link, photo, audio, video.
Requires authentication.
 * @summary Create Post
 */
export const createPostPostsPost = (
    postCreate: PostCreate,
 options?: SecondParameter<typeof customInstance>) => {
    return customInstance<PostRead>(
    {url: `/posts`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: postCreate
    },
    options);
  }



export const getCreatePostPostsPostMutationFetcher = ( options?: SecondParameter<typeof customInstance>) => {
  return (_: Key, { arg }: { arg: PostCreate }): Promise<PostRead> => {
    return createPostPostsPost(arg, options);
  }
}
export const getCreatePostPostsPostMutationKey = () => [`/posts`] as const;

export type CreatePostPostsPostMutationResult = NonNullable<Awaited<ReturnType<typeof createPostPostsPost>>>
export type CreatePostPostsPostMutationError = HTTPValidationError

/**
 * @summary Create Post
 */
export const useCreatePostPostsPost = <TError = HTTPValidationError>(
   options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof createPostPostsPost>>, TError, Key, PostCreate, Awaited<ReturnType<typeof createPostPostsPost>>> & { swrKey?: string }, request?: SecondParameter<typeof customInstance>}
) => {

  const {swr: swrOptions, request: requestOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getCreatePostPostsPostMutationKey();
  const swrFn = getCreatePostPostsPostMutationFetcher(requestOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * Get single post details with categories, tags, likes, and view count.

Increments view count for public posts.
Private/draft posts require authentication.
 * @summary Get Post
 */
export const getPostPostsPostIdGet = (
    postId: string,
 options?: SecondParameter<typeof customInstance>) => {
    return customInstance<PostRead>(
    {url: `/posts/${postId}`, method: 'GET'
    },
    options);
  }



export const getGetPostPostsPostIdGetKey = (postId: string,) => [`/posts/${postId}`] as const;

export type GetPostPostsPostIdGetQueryResult = NonNullable<Awaited<ReturnType<typeof getPostPostsPostIdGet>>>
export type GetPostPostsPostIdGetQueryError = HTTPValidationError

/**
 * @summary Get Post
 */
export const useGetPostPostsPostIdGet = <TError = HTTPValidationError>(
  postId: string, options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof getPostPostsPostIdGet>>, TError> & { swrKey?: Key, enabled?: boolean }, request?: SecondParameter<typeof customInstance> }
) => {
  const {swr: swrOptions, request: requestOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false && !!(postId)
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getGetPostPostsPostIdGetKey(postId) : null);
  const swrFn = () => getPostPostsPostIdGet(postId, requestOptions)

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * Update an existing post.

Only the author or users with appropriate permissions can update posts.
 * @summary Update Post
 */
export const updatePostPostsPostIdPut = (
    postId: string,
    postUpdate: PostUpdate,
 options?: SecondParameter<typeof customInstance>) => {
    return customInstance<PostRead>(
    {url: `/posts/${postId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: postUpdate
    },
    options);
  }



export const getUpdatePostPostsPostIdPutMutationFetcher = (postId: string, options?: SecondParameter<typeof customInstance>) => {
  return (_: Key, { arg }: { arg: PostUpdate }): Promise<PostRead> => {
    return updatePostPostsPostIdPut(postId, arg, options);
  }
}
export const getUpdatePostPostsPostIdPutMutationKey = (postId: string,) => [`/posts/${postId}`] as const;

export type UpdatePostPostsPostIdPutMutationResult = NonNullable<Awaited<ReturnType<typeof updatePostPostsPostIdPut>>>
export type UpdatePostPostsPostIdPutMutationError = HTTPValidationError

/**
 * @summary Update Post
 */
export const useUpdatePostPostsPostIdPut = <TError = HTTPValidationError>(
  postId: string, options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof updatePostPostsPostIdPut>>, TError, Key, PostUpdate, Awaited<ReturnType<typeof updatePostPostsPostIdPut>>> & { swrKey?: string }, request?: SecondParameter<typeof customInstance>}
) => {

  const {swr: swrOptions, request: requestOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getUpdatePostPostsPostIdPutMutationKey(postId);
  const swrFn = getUpdatePostPostsPostIdPutMutationFetcher(postId, requestOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * Delete a post.

Only the author or users with appropriate permissions can delete posts.
 * @summary Delete Post
 */
export const deletePostPostsPostIdDelete = (
    postId: string,
 options?: SecondParameter<typeof customInstance>) => {
    return customInstance<null>(
    {url: `/posts/${postId}`, method: 'DELETE'
    },
    options);
  }



export const getDeletePostPostsPostIdDeleteMutationFetcher = (postId: string, options?: SecondParameter<typeof customInstance>) => {
  return (_: Key, __: { arg: Arguments }): Promise<null> => {
    return deletePostPostsPostIdDelete(postId, options);
  }
}
export const getDeletePostPostsPostIdDeleteMutationKey = (postId: string,) => [`/posts/${postId}`] as const;

export type DeletePostPostsPostIdDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof deletePostPostsPostIdDelete>>>
export type DeletePostPostsPostIdDeleteMutationError = HTTPValidationError

/**
 * @summary Delete Post
 */
export const useDeletePostPostsPostIdDelete = <TError = HTTPValidationError>(
  postId: string, options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof deletePostPostsPostIdDelete>>, TError, Key, Arguments, Awaited<ReturnType<typeof deletePostPostsPostIdDelete>>> & { swrKey?: string }, request?: SecondParameter<typeof customInstance>}
) => {

  const {swr: swrOptions, request: requestOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getDeletePostPostsPostIdDeleteMutationKey(postId);
  const swrFn = getDeletePostPostsPostIdDeleteMutationFetcher(postId, requestOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * Like a post.

Creates a like entry if not already liked by the user.
 * @summary Like Post
 */
export const likePostPostsPostIdLikePost = (
    postId: string,
 options?: SecondParameter<typeof customInstance>) => {
    return customInstance<unknown>(
    {url: `/posts/${postId}/like`, method: 'POST'
    },
    options);
  }



export const getLikePostPostsPostIdLikePostMutationFetcher = (postId: string, options?: SecondParameter<typeof customInstance>) => {
  return (_: Key, __: { arg: Arguments }): Promise<unknown> => {
    return likePostPostsPostIdLikePost(postId, options);
  }
}
export const getLikePostPostsPostIdLikePostMutationKey = (postId: string,) => [`/posts/${postId}/like`] as const;

export type LikePostPostsPostIdLikePostMutationResult = NonNullable<Awaited<ReturnType<typeof likePostPostsPostIdLikePost>>>
export type LikePostPostsPostIdLikePostMutationError = HTTPValidationError

/**
 * @summary Like Post
 */
export const useLikePostPostsPostIdLikePost = <TError = HTTPValidationError>(
  postId: string, options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof likePostPostsPostIdLikePost>>, TError, Key, Arguments, Awaited<ReturnType<typeof likePostPostsPostIdLikePost>>> & { swrKey?: string }, request?: SecondParameter<typeof customInstance>}
) => {

  const {swr: swrOptions, request: requestOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getLikePostPostsPostIdLikePostMutationKey(postId);
  const swrFn = getLikePostPostsPostIdLikePostMutationFetcher(postId, requestOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * Unlike a post.

Removes the like entry if it exists.
 * @summary Unlike Post
 */
export const unlikePostPostsPostIdLikeDelete = (
    postId: string,
 options?: SecondParameter<typeof customInstance>) => {
    return customInstance<null>(
    {url: `/posts/${postId}/like`, method: 'DELETE'
    },
    options);
  }



export const getUnlikePostPostsPostIdLikeDeleteMutationFetcher = (postId: string, options?: SecondParameter<typeof customInstance>) => {
  return (_: Key, __: { arg: Arguments }): Promise<null> => {
    return unlikePostPostsPostIdLikeDelete(postId, options);
  }
}
export const getUnlikePostPostsPostIdLikeDeleteMutationKey = (postId: string,) => [`/posts/${postId}/like`] as const;

export type UnlikePostPostsPostIdLikeDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof unlikePostPostsPostIdLikeDelete>>>
export type UnlikePostPostsPostIdLikeDeleteMutationError = HTTPValidationError

/**
 * @summary Unlike Post
 */
export const useUnlikePostPostsPostIdLikeDelete = <TError = HTTPValidationError>(
  postId: string, options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof unlikePostPostsPostIdLikeDelete>>, TError, Key, Arguments, Awaited<ReturnType<typeof unlikePostPostsPostIdLikeDelete>>> & { swrKey?: string }, request?: SecondParameter<typeof customInstance>}
) => {

  const {swr: swrOptions, request: requestOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getUnlikePostPostsPostIdLikeDeleteMutationKey(postId);
  const swrFn = getUnlikePostPostsPostIdLikeDeleteMutationFetcher(postId, requestOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * Create a new category.
 * @summary Create Category
 */
export const createCategoryCategoriesPost = (
    categoryCreate: CategoryCreate,
 options?: SecondParameter<typeof customInstance>) => {
    return customInstance<CategoryRead>(
    {url: `/categories/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: categoryCreate
    },
    options);
  }



export const getCreateCategoryCategoriesPostMutationFetcher = ( options?: SecondParameter<typeof customInstance>) => {
  return (_: Key, { arg }: { arg: CategoryCreate }): Promise<CategoryRead> => {
    return createCategoryCategoriesPost(arg, options);
  }
}
export const getCreateCategoryCategoriesPostMutationKey = () => [`/categories/`] as const;

export type CreateCategoryCategoriesPostMutationResult = NonNullable<Awaited<ReturnType<typeof createCategoryCategoriesPost>>>
export type CreateCategoryCategoriesPostMutationError = HTTPValidationError

/**
 * @summary Create Category
 */
export const useCreateCategoryCategoriesPost = <TError = HTTPValidationError>(
   options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof createCategoryCategoriesPost>>, TError, Key, CategoryCreate, Awaited<ReturnType<typeof createCategoryCategoriesPost>>> & { swrKey?: string }, request?: SecondParameter<typeof customInstance>}
) => {

  const {swr: swrOptions, request: requestOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getCreateCategoryCategoriesPostMutationKey();
  const swrFn = getCreateCategoryCategoriesPostMutationFetcher(requestOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * List all categories with pagination.
 * @summary List Categories
 */
export const listCategoriesCategoriesGet = (
    params?: ListCategoriesCategoriesGetParams,
 options?: SecondParameter<typeof customInstance>) => {
    return customInstance<CategoryRead[]>(
    {url: `/categories/`, method: 'GET',
        params
    },
    options);
  }



export const getListCategoriesCategoriesGetKey = (params?: ListCategoriesCategoriesGetParams,) => [`/categories/`, ...(params ? [params]: [])] as const;

export type ListCategoriesCategoriesGetQueryResult = NonNullable<Awaited<ReturnType<typeof listCategoriesCategoriesGet>>>
export type ListCategoriesCategoriesGetQueryError = HTTPValidationError

/**
 * @summary List Categories
 */
export const useListCategoriesCategoriesGet = <TError = HTTPValidationError>(
  params?: ListCategoriesCategoriesGetParams, options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof listCategoriesCategoriesGet>>, TError> & { swrKey?: Key, enabled?: boolean }, request?: SecondParameter<typeof customInstance> }
) => {
  const {swr: swrOptions, request: requestOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getListCategoriesCategoriesGetKey(params) : null);
  const swrFn = () => listCategoriesCategoriesGet(params, requestOptions)

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * Get category by ID.
 * @summary Get Category
 */
export const getCategoryCategoriesCategoryIdGet = (
    categoryId: number,
 options?: SecondParameter<typeof customInstance>) => {
    return customInstance<CategoryRead>(
    {url: `/categories/${categoryId}`, method: 'GET'
    },
    options);
  }



export const getGetCategoryCategoriesCategoryIdGetKey = (categoryId: number,) => [`/categories/${categoryId}`] as const;

export type GetCategoryCategoriesCategoryIdGetQueryResult = NonNullable<Awaited<ReturnType<typeof getCategoryCategoriesCategoryIdGet>>>
export type GetCategoryCategoriesCategoryIdGetQueryError = HTTPValidationError

/**
 * @summary Get Category
 */
export const useGetCategoryCategoriesCategoryIdGet = <TError = HTTPValidationError>(
  categoryId: number, options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof getCategoryCategoriesCategoryIdGet>>, TError> & { swrKey?: Key, enabled?: boolean }, request?: SecondParameter<typeof customInstance> }
) => {
  const {swr: swrOptions, request: requestOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false && !!(categoryId)
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getGetCategoryCategoriesCategoryIdGetKey(categoryId) : null);
  const swrFn = () => getCategoryCategoriesCategoryIdGet(categoryId, requestOptions)

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * Update category (authenticated users only).
 * @summary Update Category
 */
export const updateCategoryCategoriesCategoryIdPut = (
    categoryId: number,
    categoryUpdate: CategoryUpdate,
 options?: SecondParameter<typeof customInstance>) => {
    return customInstance<CategoryRead>(
    {url: `/categories/${categoryId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: categoryUpdate
    },
    options);
  }



export const getUpdateCategoryCategoriesCategoryIdPutMutationFetcher = (categoryId: number, options?: SecondParameter<typeof customInstance>) => {
  return (_: Key, { arg }: { arg: CategoryUpdate }): Promise<CategoryRead> => {
    return updateCategoryCategoriesCategoryIdPut(categoryId, arg, options);
  }
}
export const getUpdateCategoryCategoriesCategoryIdPutMutationKey = (categoryId: number,) => [`/categories/${categoryId}`] as const;

export type UpdateCategoryCategoriesCategoryIdPutMutationResult = NonNullable<Awaited<ReturnType<typeof updateCategoryCategoriesCategoryIdPut>>>
export type UpdateCategoryCategoriesCategoryIdPutMutationError = HTTPValidationError

/**
 * @summary Update Category
 */
export const useUpdateCategoryCategoriesCategoryIdPut = <TError = HTTPValidationError>(
  categoryId: number, options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof updateCategoryCategoriesCategoryIdPut>>, TError, Key, CategoryUpdate, Awaited<ReturnType<typeof updateCategoryCategoriesCategoryIdPut>>> & { swrKey?: string }, request?: SecondParameter<typeof customInstance>}
) => {

  const {swr: swrOptions, request: requestOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getUpdateCategoryCategoriesCategoryIdPutMutationKey(categoryId);
  const swrFn = getUpdateCategoryCategoriesCategoryIdPutMutationFetcher(categoryId, requestOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * Delete category (authenticated users only).
 * @summary Delete Category
 */
export const deleteCategoryCategoriesCategoryIdDelete = (
    categoryId: number,
 options?: SecondParameter<typeof customInstance>) => {
    return customInstance<unknown>(
    {url: `/categories/${categoryId}`, method: 'DELETE'
    },
    options);
  }



export const getDeleteCategoryCategoriesCategoryIdDeleteMutationFetcher = (categoryId: number, options?: SecondParameter<typeof customInstance>) => {
  return (_: Key, __: { arg: Arguments }): Promise<unknown> => {
    return deleteCategoryCategoriesCategoryIdDelete(categoryId, options);
  }
}
export const getDeleteCategoryCategoriesCategoryIdDeleteMutationKey = (categoryId: number,) => [`/categories/${categoryId}`] as const;

export type DeleteCategoryCategoriesCategoryIdDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof deleteCategoryCategoriesCategoryIdDelete>>>
export type DeleteCategoryCategoriesCategoryIdDeleteMutationError = HTTPValidationError

/**
 * @summary Delete Category
 */
export const useDeleteCategoryCategoriesCategoryIdDelete = <TError = HTTPValidationError>(
  categoryId: number, options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof deleteCategoryCategoriesCategoryIdDelete>>, TError, Key, Arguments, Awaited<ReturnType<typeof deleteCategoryCategoriesCategoryIdDelete>>> & { swrKey?: string }, request?: SecondParameter<typeof customInstance>}
) => {

  const {swr: swrOptions, request: requestOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getDeleteCategoryCategoriesCategoryIdDeleteMutationKey(categoryId);
  const swrFn = getDeleteCategoryCategoriesCategoryIdDeleteMutationFetcher(categoryId, requestOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * Create a new tag.
 * @summary Create Tag
 */
export const createTagTagsPost = (
    tagCreate: TagCreate,
 options?: SecondParameter<typeof customInstance>) => {
    return customInstance<TagRead>(
    {url: `/tags/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: tagCreate
    },
    options);
  }



export const getCreateTagTagsPostMutationFetcher = ( options?: SecondParameter<typeof customInstance>) => {
  return (_: Key, { arg }: { arg: TagCreate }): Promise<TagRead> => {
    return createTagTagsPost(arg, options);
  }
}
export const getCreateTagTagsPostMutationKey = () => [`/tags/`] as const;

export type CreateTagTagsPostMutationResult = NonNullable<Awaited<ReturnType<typeof createTagTagsPost>>>
export type CreateTagTagsPostMutationError = HTTPValidationError

/**
 * @summary Create Tag
 */
export const useCreateTagTagsPost = <TError = HTTPValidationError>(
   options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof createTagTagsPost>>, TError, Key, TagCreate, Awaited<ReturnType<typeof createTagTagsPost>>> & { swrKey?: string }, request?: SecondParameter<typeof customInstance>}
) => {

  const {swr: swrOptions, request: requestOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getCreateTagTagsPostMutationKey();
  const swrFn = getCreateTagTagsPostMutationFetcher(requestOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * List all tags with pagination and optional search.
 * @summary List Tags
 */
export const listTagsTagsGet = (
    params?: ListTagsTagsGetParams,
 options?: SecondParameter<typeof customInstance>) => {
    return customInstance<TagRead[]>(
    {url: `/tags/`, method: 'GET',
        params
    },
    options);
  }



export const getListTagsTagsGetKey = (params?: ListTagsTagsGetParams,) => [`/tags/`, ...(params ? [params]: [])] as const;

export type ListTagsTagsGetQueryResult = NonNullable<Awaited<ReturnType<typeof listTagsTagsGet>>>
export type ListTagsTagsGetQueryError = HTTPValidationError

/**
 * @summary List Tags
 */
export const useListTagsTagsGet = <TError = HTTPValidationError>(
  params?: ListTagsTagsGetParams, options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof listTagsTagsGet>>, TError> & { swrKey?: Key, enabled?: boolean }, request?: SecondParameter<typeof customInstance> }
) => {
  const {swr: swrOptions, request: requestOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getListTagsTagsGetKey(params) : null);
  const swrFn = () => listTagsTagsGet(params, requestOptions)

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * Delete tag (authenticated users only).
 * @summary Delete Tag
 */
export const deleteTagTagsTagIdDelete = (
    tagId: number,
 options?: SecondParameter<typeof customInstance>) => {
    return customInstance<unknown>(
    {url: `/tags/${tagId}`, method: 'DELETE'
    },
    options);
  }



export const getDeleteTagTagsTagIdDeleteMutationFetcher = (tagId: number, options?: SecondParameter<typeof customInstance>) => {
  return (_: Key, __: { arg: Arguments }): Promise<unknown> => {
    return deleteTagTagsTagIdDelete(tagId, options);
  }
}
export const getDeleteTagTagsTagIdDeleteMutationKey = (tagId: number,) => [`/tags/${tagId}`] as const;

export type DeleteTagTagsTagIdDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof deleteTagTagsTagIdDelete>>>
export type DeleteTagTagsTagIdDeleteMutationError = HTTPValidationError

/**
 * @summary Delete Tag
 */
export const useDeleteTagTagsTagIdDelete = <TError = HTTPValidationError>(
  tagId: number, options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof deleteTagTagsTagIdDelete>>, TError, Key, Arguments, Awaited<ReturnType<typeof deleteTagTagsTagIdDelete>>> & { swrKey?: string }, request?: SecondParameter<typeof customInstance>}
) => {

  const {swr: swrOptions, request: requestOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getDeleteTagTagsTagIdDeleteMutationKey(tagId);
  const swrFn = getDeleteTagTagsTagIdDeleteMutationFetcher(tagId, requestOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * Create a new comment for a post.
 * @summary Create Comment
 */
export const createCommentPostsPostIdCommentsPost = (
    postId: string,
    commentCreate: CommentCreate,
 options?: SecondParameter<typeof customInstance>) => {
    return customInstance<CommentRead>(
    {url: `/posts/${postId}/comments`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: commentCreate
    },
    options);
  }



export const getCreateCommentPostsPostIdCommentsPostMutationFetcher = (postId: string, options?: SecondParameter<typeof customInstance>) => {
  return (_: Key, { arg }: { arg: CommentCreate }): Promise<CommentRead> => {
    return createCommentPostsPostIdCommentsPost(postId, arg, options);
  }
}
export const getCreateCommentPostsPostIdCommentsPostMutationKey = (postId: string,) => [`/posts/${postId}/comments`] as const;

export type CreateCommentPostsPostIdCommentsPostMutationResult = NonNullable<Awaited<ReturnType<typeof createCommentPostsPostIdCommentsPost>>>
export type CreateCommentPostsPostIdCommentsPostMutationError = HTTPValidationError

/**
 * @summary Create Comment
 */
export const useCreateCommentPostsPostIdCommentsPost = <TError = HTTPValidationError>(
  postId: string, options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof createCommentPostsPostIdCommentsPost>>, TError, Key, CommentCreate, Awaited<ReturnType<typeof createCommentPostsPostIdCommentsPost>>> & { swrKey?: string }, request?: SecondParameter<typeof customInstance>}
) => {

  const {swr: swrOptions, request: requestOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getCreateCommentPostsPostIdCommentsPostMutationKey(postId);
  const swrFn = getCreateCommentPostsPostIdCommentsPostMutationFetcher(postId, requestOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * List comments for a post.
 * @summary List Post Comments
 */
export const listPostCommentsPostsPostIdCommentsGet = (
    postId: string,
    params?: ListPostCommentsPostsPostIdCommentsGetParams,
 options?: SecondParameter<typeof customInstance>) => {
    return customInstance<CommentRead[]>(
    {url: `/posts/${postId}/comments`, method: 'GET',
        params
    },
    options);
  }



export const getListPostCommentsPostsPostIdCommentsGetKey = (postId: string,
    params?: ListPostCommentsPostsPostIdCommentsGetParams,) => [`/posts/${postId}/comments`, ...(params ? [params]: [])] as const;

export type ListPostCommentsPostsPostIdCommentsGetQueryResult = NonNullable<Awaited<ReturnType<typeof listPostCommentsPostsPostIdCommentsGet>>>
export type ListPostCommentsPostsPostIdCommentsGetQueryError = HTTPValidationError

/**
 * @summary List Post Comments
 */
export const useListPostCommentsPostsPostIdCommentsGet = <TError = HTTPValidationError>(
  postId: string,
    params?: ListPostCommentsPostsPostIdCommentsGetParams, options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof listPostCommentsPostsPostIdCommentsGet>>, TError> & { swrKey?: Key, enabled?: boolean }, request?: SecondParameter<typeof customInstance> }
) => {
  const {swr: swrOptions, request: requestOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false && !!(postId)
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getListPostCommentsPostsPostIdCommentsGetKey(postId,params) : null);
  const swrFn = () => listPostCommentsPostsPostIdCommentsGet(postId,params, requestOptions)

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * Update comment (author only).
 * @summary Update Comment
 */
export const updateCommentCommentsCommentIdPut = (
    commentId: string,
    commentUpdate: CommentUpdate,
 options?: SecondParameter<typeof customInstance>) => {
    return customInstance<CommentRead>(
    {url: `/comments/${commentId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: commentUpdate
    },
    options);
  }



export const getUpdateCommentCommentsCommentIdPutMutationFetcher = (commentId: string, options?: SecondParameter<typeof customInstance>) => {
  return (_: Key, { arg }: { arg: CommentUpdate }): Promise<CommentRead> => {
    return updateCommentCommentsCommentIdPut(commentId, arg, options);
  }
}
export const getUpdateCommentCommentsCommentIdPutMutationKey = (commentId: string,) => [`/comments/${commentId}`] as const;

export type UpdateCommentCommentsCommentIdPutMutationResult = NonNullable<Awaited<ReturnType<typeof updateCommentCommentsCommentIdPut>>>
export type UpdateCommentCommentsCommentIdPutMutationError = HTTPValidationError

/**
 * @summary Update Comment
 */
export const useUpdateCommentCommentsCommentIdPut = <TError = HTTPValidationError>(
  commentId: string, options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof updateCommentCommentsCommentIdPut>>, TError, Key, CommentUpdate, Awaited<ReturnType<typeof updateCommentCommentsCommentIdPut>>> & { swrKey?: string }, request?: SecondParameter<typeof customInstance>}
) => {

  const {swr: swrOptions, request: requestOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getUpdateCommentCommentsCommentIdPutMutationKey(commentId);
  const swrFn = getUpdateCommentCommentsCommentIdPutMutationFetcher(commentId, requestOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * Delete comment (author only).
 * @summary Delete Comment
 */
export const deleteCommentCommentsCommentIdDelete = (
    commentId: string,
 options?: SecondParameter<typeof customInstance>) => {
    return customInstance<unknown>(
    {url: `/comments/${commentId}`, method: 'DELETE'
    },
    options);
  }



export const getDeleteCommentCommentsCommentIdDeleteMutationFetcher = (commentId: string, options?: SecondParameter<typeof customInstance>) => {
  return (_: Key, __: { arg: Arguments }): Promise<unknown> => {
    return deleteCommentCommentsCommentIdDelete(commentId, options);
  }
}
export const getDeleteCommentCommentsCommentIdDeleteMutationKey = (commentId: string,) => [`/comments/${commentId}`] as const;

export type DeleteCommentCommentsCommentIdDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof deleteCommentCommentsCommentIdDelete>>>
export type DeleteCommentCommentsCommentIdDeleteMutationError = HTTPValidationError

/**
 * @summary Delete Comment
 */
export const useDeleteCommentCommentsCommentIdDelete = <TError = HTTPValidationError>(
  commentId: string, options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof deleteCommentCommentsCommentIdDelete>>, TError, Key, Arguments, Awaited<ReturnType<typeof deleteCommentCommentsCommentIdDelete>>> & { swrKey?: string }, request?: SecondParameter<typeof customInstance>}
) => {

  const {swr: swrOptions, request: requestOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getDeleteCommentCommentsCommentIdDeleteMutationKey(commentId);
  const swrFn = getDeleteCommentCommentsCommentIdDeleteMutationFetcher(commentId, requestOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * Like a post.
 * @summary Create Like
 */
export const createLikePostsPostIdLikesPost = (
    postId: string,
    likeCreate: LikeCreate,
 options?: SecondParameter<typeof customInstance>) => {
    return customInstance<LikeRead>(
    {url: `/posts/${postId}/likes`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: likeCreate
    },
    options);
  }



export const getCreateLikePostsPostIdLikesPostMutationFetcher = (postId: string, options?: SecondParameter<typeof customInstance>) => {
  return (_: Key, { arg }: { arg: LikeCreate }): Promise<LikeRead> => {
    return createLikePostsPostIdLikesPost(postId, arg, options);
  }
}
export const getCreateLikePostsPostIdLikesPostMutationKey = (postId: string,) => [`/posts/${postId}/likes`] as const;

export type CreateLikePostsPostIdLikesPostMutationResult = NonNullable<Awaited<ReturnType<typeof createLikePostsPostIdLikesPost>>>
export type CreateLikePostsPostIdLikesPostMutationError = HTTPValidationError

/**
 * @summary Create Like
 */
export const useCreateLikePostsPostIdLikesPost = <TError = HTTPValidationError>(
  postId: string, options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof createLikePostsPostIdLikesPost>>, TError, Key, LikeCreate, Awaited<ReturnType<typeof createLikePostsPostIdLikesPost>>> & { swrKey?: string }, request?: SecondParameter<typeof customInstance>}
) => {

  const {swr: swrOptions, request: requestOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getCreateLikePostsPostIdLikesPostMutationKey(postId);
  const swrFn = getCreateLikePostsPostIdLikesPostMutationFetcher(postId, requestOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * Unlike a post.
 * @summary Delete Like
 */
export const deleteLikePostsPostIdLikesDelete = (
    postId: string,
 options?: SecondParameter<typeof customInstance>) => {
    return customInstance<unknown>(
    {url: `/posts/${postId}/likes`, method: 'DELETE'
    },
    options);
  }



export const getDeleteLikePostsPostIdLikesDeleteMutationFetcher = (postId: string, options?: SecondParameter<typeof customInstance>) => {
  return (_: Key, __: { arg: Arguments }): Promise<unknown> => {
    return deleteLikePostsPostIdLikesDelete(postId, options);
  }
}
export const getDeleteLikePostsPostIdLikesDeleteMutationKey = (postId: string,) => [`/posts/${postId}/likes`] as const;

export type DeleteLikePostsPostIdLikesDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof deleteLikePostsPostIdLikesDelete>>>
export type DeleteLikePostsPostIdLikesDeleteMutationError = HTTPValidationError

/**
 * @summary Delete Like
 */
export const useDeleteLikePostsPostIdLikesDelete = <TError = HTTPValidationError>(
  postId: string, options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof deleteLikePostsPostIdLikesDelete>>, TError, Key, Arguments, Awaited<ReturnType<typeof deleteLikePostsPostIdLikesDelete>>> & { swrKey?: string }, request?: SecondParameter<typeof customInstance>}
) => {

  const {swr: swrOptions, request: requestOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getDeleteLikePostsPostIdLikesDeleteMutationKey(postId);
  const swrFn = getDeleteLikePostsPostIdLikesDeleteMutationFetcher(postId, requestOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * List who liked a post.
 * @summary List Post Likes
 */
export const listPostLikesPostsPostIdLikesGet = (
    postId: string,
    params?: ListPostLikesPostsPostIdLikesGetParams,
 options?: SecondParameter<typeof customInstance>) => {
    return customInstance<LikeRead[]>(
    {url: `/posts/${postId}/likes`, method: 'GET',
        params
    },
    options);
  }



export const getListPostLikesPostsPostIdLikesGetKey = (postId: string,
    params?: ListPostLikesPostsPostIdLikesGetParams,) => [`/posts/${postId}/likes`, ...(params ? [params]: [])] as const;

export type ListPostLikesPostsPostIdLikesGetQueryResult = NonNullable<Awaited<ReturnType<typeof listPostLikesPostsPostIdLikesGet>>>
export type ListPostLikesPostsPostIdLikesGetQueryError = HTTPValidationError

/**
 * @summary List Post Likes
 */
export const useListPostLikesPostsPostIdLikesGet = <TError = HTTPValidationError>(
  postId: string,
    params?: ListPostLikesPostsPostIdLikesGetParams, options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof listPostLikesPostsPostIdLikesGet>>, TError> & { swrKey?: Key, enabled?: boolean }, request?: SecondParameter<typeof customInstance> }
) => {
  const {swr: swrOptions, request: requestOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false && !!(postId)
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getListPostLikesPostsPostIdLikesGetKey(postId,params) : null);
  const swrFn = () => listPostLikesPostsPostIdLikesGet(postId,params, requestOptions)

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * List all available themes.

Returns all themes with their configuration and status.
 * @summary List Themes
 */
export const listThemesThemesGet = (
    
 options?: SecondParameter<typeof customInstance>) => {
    return customInstance<ThemeRead[]>(
    {url: `/themes`, method: 'GET'
    },
    options);
  }



export const getListThemesThemesGetKey = () => [`/themes`] as const;

export type ListThemesThemesGetQueryResult = NonNullable<Awaited<ReturnType<typeof listThemesThemesGet>>>
export type ListThemesThemesGetQueryError = unknown

/**
 * @summary List Themes
 */
export const useListThemesThemesGet = <TError = unknown>(
   options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof listThemesThemesGet>>, TError> & { swrKey?: Key, enabled?: boolean }, request?: SecondParameter<typeof customInstance> }
) => {
  const {swr: swrOptions, request: requestOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getListThemesThemesGetKey() : null);
  const swrFn = () => listThemesThemesGet(requestOptions)

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * Activate a theme.

Deactivates all other themes and activates the specified one.
Requires authentication and appropriate permissions.
 * @summary Activate Theme
 */
export const activateThemeThemesThemeIdActivatePut = (
    themeId: number,
 options?: SecondParameter<typeof customInstance>) => {
    return customInstance<ThemeRead>(
    {url: `/themes/${themeId}/activate`, method: 'PUT'
    },
    options);
  }



export const getActivateThemeThemesThemeIdActivatePutMutationFetcher = (themeId: number, options?: SecondParameter<typeof customInstance>) => {
  return (_: Key, __: { arg: Arguments }): Promise<ThemeRead> => {
    return activateThemeThemesThemeIdActivatePut(themeId, options);
  }
}
export const getActivateThemeThemesThemeIdActivatePutMutationKey = (themeId: number,) => [`/themes/${themeId}/activate`] as const;

export type ActivateThemeThemesThemeIdActivatePutMutationResult = NonNullable<Awaited<ReturnType<typeof activateThemeThemesThemeIdActivatePut>>>
export type ActivateThemeThemesThemeIdActivatePutMutationError = HTTPValidationError

/**
 * @summary Activate Theme
 */
export const useActivateThemeThemesThemeIdActivatePut = <TError = HTTPValidationError>(
  themeId: number, options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof activateThemeThemesThemeIdActivatePut>>, TError, Key, Arguments, Awaited<ReturnType<typeof activateThemeThemesThemeIdActivatePut>>> & { swrKey?: string }, request?: SecondParameter<typeof customInstance>}
) => {

  const {swr: swrOptions, request: requestOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getActivateThemeThemesThemeIdActivatePutMutationKey(themeId);
  const swrFn = getActivateThemeThemesThemeIdActivatePutMutationFetcher(themeId, requestOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * Get the currently active theme.

Returns the active theme configuration.
 * @summary Get Active Theme
 */
export const getActiveThemeThemesActiveGet = (
    
 options?: SecondParameter<typeof customInstance>) => {
    return customInstance<ThemeRead>(
    {url: `/themes/active`, method: 'GET'
    },
    options);
  }



export const getGetActiveThemeThemesActiveGetKey = () => [`/themes/active`] as const;

export type GetActiveThemeThemesActiveGetQueryResult = NonNullable<Awaited<ReturnType<typeof getActiveThemeThemesActiveGet>>>
export type GetActiveThemeThemesActiveGetQueryError = unknown

/**
 * @summary Get Active Theme
 */
export const useGetActiveThemeThemesActiveGet = <TError = unknown>(
   options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof getActiveThemeThemesActiveGet>>, TError> & { swrKey?: Key, enabled?: boolean }, request?: SecondParameter<typeof customInstance> }
) => {
  const {swr: swrOptions, request: requestOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getGetActiveThemeThemesActiveGetKey() : null);
  const swrFn = () => getActiveThemeThemesActiveGet(requestOptions)

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * Upload single or multiple files.

Files are stored in the media directory configured via MEDIA_DIR env variable.
Supports associating files with a specific post.
 * @summary Upload Files
 */
export const uploadFilesUploadPost = (
    bodyUploadFilesUploadPost: BodyUploadFilesUploadPost,
 options?: SecondParameter<typeof customInstance>) => {const formData = new FormData();
bodyUploadFilesUploadPost.files.forEach(value => formData.append(`files`, value));
if(bodyUploadFilesUploadPost.post_id !== undefined && bodyUploadFilesUploadPost.post_id !== null) {
 formData.append(`post_id`, bodyUploadFilesUploadPost.post_id)
 }

    return customInstance<PostFile[]>(
    {url: `/upload`, method: 'POST',
      headers: {'Content-Type': 'multipart/form-data', },
       data: formData
    },
    options);
  }



export const getUploadFilesUploadPostMutationFetcher = ( options?: SecondParameter<typeof customInstance>) => {
  return (_: Key, { arg }: { arg: BodyUploadFilesUploadPost }): Promise<PostFile[]> => {
    return uploadFilesUploadPost(arg, options);
  }
}
export const getUploadFilesUploadPostMutationKey = () => [`/upload`] as const;

export type UploadFilesUploadPostMutationResult = NonNullable<Awaited<ReturnType<typeof uploadFilesUploadPost>>>
export type UploadFilesUploadPostMutationError = HTTPValidationError

/**
 * @summary Upload Files
 */
export const useUploadFilesUploadPost = <TError = HTTPValidationError>(
   options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof uploadFilesUploadPost>>, TError, Key, BodyUploadFilesUploadPost, Awaited<ReturnType<typeof uploadFilesUploadPost>>> & { swrKey?: string }, request?: SecondParameter<typeof customInstance>}
) => {

  const {swr: swrOptions, request: requestOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getUploadFilesUploadPostMutationKey();
  const swrFn = getUploadFilesUploadPostMutationFetcher(requestOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * List uploaded files.

Can be filtered by post ID. Supports pagination.
 * @summary List Files
 */
export const listFilesUploadGet = (
    params?: ListFilesUploadGetParams,
 options?: SecondParameter<typeof customInstance>) => {
    return customInstance<PostFileRead[]>(
    {url: `/upload`, method: 'GET',
        params
    },
    options);
  }



export const getListFilesUploadGetKey = (params?: ListFilesUploadGetParams,) => [`/upload`, ...(params ? [params]: [])] as const;

export type ListFilesUploadGetQueryResult = NonNullable<Awaited<ReturnType<typeof listFilesUploadGet>>>
export type ListFilesUploadGetQueryError = HTTPValidationError

/**
 * @summary List Files
 */
export const useListFilesUploadGet = <TError = HTTPValidationError>(
  params?: ListFilesUploadGetParams, options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof listFilesUploadGet>>, TError> & { swrKey?: Key, enabled?: boolean }, request?: SecondParameter<typeof customInstance> }
) => {
  const {swr: swrOptions, request: requestOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getListFilesUploadGetKey(params) : null);
  const swrFn = () => listFilesUploadGet(params, requestOptions)

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * Delete an uploaded file.

Removes both the database record and the physical file.
Only the file owner or users with appropriate permissions can delete files.
 * @summary Delete File
 */
export const deleteFileUploadFileIdDelete = (
    fileId: string,
 options?: SecondParameter<typeof customInstance>) => {
    return customInstance<null>(
    {url: `/upload/${fileId}`, method: 'DELETE'
    },
    options);
  }



export const getDeleteFileUploadFileIdDeleteMutationFetcher = (fileId: string, options?: SecondParameter<typeof customInstance>) => {
  return (_: Key, __: { arg: Arguments }): Promise<null> => {
    return deleteFileUploadFileIdDelete(fileId, options);
  }
}
export const getDeleteFileUploadFileIdDeleteMutationKey = (fileId: string,) => [`/upload/${fileId}`] as const;

export type DeleteFileUploadFileIdDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof deleteFileUploadFileIdDelete>>>
export type DeleteFileUploadFileIdDeleteMutationError = HTTPValidationError

/**
 * @summary Delete File
 */
export const useDeleteFileUploadFileIdDelete = <TError = HTTPValidationError>(
  fileId: string, options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof deleteFileUploadFileIdDelete>>, TError, Key, Arguments, Awaited<ReturnType<typeof deleteFileUploadFileIdDelete>>> & { swrKey?: string }, request?: SecondParameter<typeof customInstance>}
) => {

  const {swr: swrOptions, request: requestOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getDeleteFileUploadFileIdDeleteMutationKey(fileId);
  const swrFn = getDeleteFileUploadFileIdDeleteMutationFetcher(fileId, requestOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * Get file metadata.

Returns file information without serving the actual file content.
 * @summary Get File Metadata
 */
export const getFileMetadataUploadFileIdGet = (
    fileId: string,
 options?: SecondParameter<typeof customInstance>) => {
    return customInstance<PostFileRead>(
    {url: `/upload/${fileId}`, method: 'GET'
    },
    options);
  }



export const getGetFileMetadataUploadFileIdGetKey = (fileId: string,) => [`/upload/${fileId}`] as const;

export type GetFileMetadataUploadFileIdGetQueryResult = NonNullable<Awaited<ReturnType<typeof getFileMetadataUploadFileIdGet>>>
export type GetFileMetadataUploadFileIdGetQueryError = HTTPValidationError

/**
 * @summary Get File Metadata
 */
export const useGetFileMetadataUploadFileIdGet = <TError = HTTPValidationError>(
  fileId: string, options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof getFileMetadataUploadFileIdGet>>, TError> & { swrKey?: Key, enabled?: boolean }, request?: SecondParameter<typeof customInstance> }
) => {
  const {swr: swrOptions, request: requestOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false && !!(fileId)
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getGetFileMetadataUploadFileIdGetKey(fileId) : null);
  const swrFn = () => getFileMetadataUploadFileIdGet(fileId, requestOptions)

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * Download the actual file.

Serves the file content with appropriate headers.
 * @summary Download File
 */
export const downloadFileUploadFileIdDownloadGet = (
    fileId: string,
 options?: SecondParameter<typeof customInstance>) => {
    return customInstance<unknown>(
    {url: `/upload/${fileId}/download`, method: 'GET'
    },
    options);
  }



export const getDownloadFileUploadFileIdDownloadGetKey = (fileId: string,) => [`/upload/${fileId}/download`] as const;

export type DownloadFileUploadFileIdDownloadGetQueryResult = NonNullable<Awaited<ReturnType<typeof downloadFileUploadFileIdDownloadGet>>>
export type DownloadFileUploadFileIdDownloadGetQueryError = HTTPValidationError

/**
 * @summary Download File
 */
export const useDownloadFileUploadFileIdDownloadGet = <TError = HTTPValidationError>(
  fileId: string, options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof downloadFileUploadFileIdDownloadGet>>, TError> & { swrKey?: Key, enabled?: boolean }, request?: SecondParameter<typeof customInstance> }
) => {
  const {swr: swrOptions, request: requestOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false && !!(fileId)
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getDownloadFileUploadFileIdDownloadGetKey(fileId) : null);
  const swrFn = () => downloadFileUploadFileIdDownloadGet(fileId, requestOptions)

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * Get general site information including:
- User information (if authenticated) 
- Blog title and description
- List of active extensions
- Current theme
- Public settings
- Enabled features

This endpoint provides all the essential information needed
to configure the frontend application.
 * @summary Get Site Info
 */
export const getSiteInfoSiteInfoGet = (
    
 options?: SecondParameter<typeof customInstance>) => {
    return customInstance<SiteInfoResponse>(
    {url: `/site/info`, method: 'GET'
    },
    options);
  }



export const getGetSiteInfoSiteInfoGetKey = () => [`/site/info`] as const;

export type GetSiteInfoSiteInfoGetQueryResult = NonNullable<Awaited<ReturnType<typeof getSiteInfoSiteInfoGet>>>
export type GetSiteInfoSiteInfoGetQueryError = unknown

/**
 * @summary Get Site Info
 */
export const useGetSiteInfoSiteInfoGet = <TError = unknown>(
   options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof getSiteInfoSiteInfoGet>>, TError> & { swrKey?: Key, enabled?: boolean }, request?: SecondParameter<typeof customInstance> }
) => {
  const {swr: swrOptions, request: requestOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getGetSiteInfoSiteInfoGetKey() : null);
  const swrFn = () => getSiteInfoSiteInfoGet(requestOptions)

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * Get all extensions or only active ones.

This endpoint returns detailed information about extensions
including their configuration and status.
 * @summary Get Extensions
 */
export const getExtensionsSiteExtensionsGet = (
    params?: GetExtensionsSiteExtensionsGetParams,
 options?: SecondParameter<typeof customInstance>) => {
    return customInstance<ExtensionsResponse>(
    {url: `/site/extensions`, method: 'GET',
        params
    },
    options);
  }



export const getGetExtensionsSiteExtensionsGetKey = (params?: GetExtensionsSiteExtensionsGetParams,) => [`/site/extensions`, ...(params ? [params]: [])] as const;

export type GetExtensionsSiteExtensionsGetQueryResult = NonNullable<Awaited<ReturnType<typeof getExtensionsSiteExtensionsGet>>>
export type GetExtensionsSiteExtensionsGetQueryError = HTTPValidationError

/**
 * @summary Get Extensions
 */
export const useGetExtensionsSiteExtensionsGet = <TError = HTTPValidationError>(
  params?: GetExtensionsSiteExtensionsGetParams, options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof getExtensionsSiteExtensionsGet>>, TError> & { swrKey?: Key, enabled?: boolean }, request?: SecondParameter<typeof customInstance> }
) => {
  const {swr: swrOptions, request: requestOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getGetExtensionsSiteExtensionsGetKey(params) : null);
  const swrFn = () => getExtensionsSiteExtensionsGet(params, requestOptions)

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * Get list of active extension names.

Returns a simple list of extension names that are currently active.
Useful for quick feature detection in the frontend.
 * @summary Get Active Extension Names
 */
export const getActiveExtensionNamesSiteExtensionsActiveGet = (
    
 options?: SecondParameter<typeof customInstance>) => {
    return customInstance<string[]>(
    {url: `/site/extensions/active`, method: 'GET'
    },
    options);
  }



export const getGetActiveExtensionNamesSiteExtensionsActiveGetKey = () => [`/site/extensions/active`] as const;

export type GetActiveExtensionNamesSiteExtensionsActiveGetQueryResult = NonNullable<Awaited<ReturnType<typeof getActiveExtensionNamesSiteExtensionsActiveGet>>>
export type GetActiveExtensionNamesSiteExtensionsActiveGetQueryError = unknown

/**
 * @summary Get Active Extension Names
 */
export const useGetActiveExtensionNamesSiteExtensionsActiveGet = <TError = unknown>(
   options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof getActiveExtensionNamesSiteExtensionsActiveGet>>, TError> & { swrKey?: Key, enabled?: boolean }, request?: SecondParameter<typeof customInstance> }
) => {
  const {swr: swrOptions, request: requestOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getGetActiveExtensionNamesSiteExtensionsActiveGetKey() : null);
  const swrFn = () => getActiveExtensionNamesSiteExtensionsActiveGet(requestOptions)

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * Get list of enabled features.

Returns a list of feature flags that indicate what functionality
is available on this site (comments, registration, uploads, etc.).
 * @summary Get Enabled Features
 */
export const getEnabledFeaturesSiteFeaturesGet = (
    
 options?: SecondParameter<typeof customInstance>) => {
    return customInstance<string[]>(
    {url: `/site/features`, method: 'GET'
    },
    options);
  }



export const getGetEnabledFeaturesSiteFeaturesGetKey = () => [`/site/features`] as const;

export type GetEnabledFeaturesSiteFeaturesGetQueryResult = NonNullable<Awaited<ReturnType<typeof getEnabledFeaturesSiteFeaturesGet>>>
export type GetEnabledFeaturesSiteFeaturesGetQueryError = unknown

/**
 * @summary Get Enabled Features
 */
export const useGetEnabledFeaturesSiteFeaturesGet = <TError = unknown>(
   options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof getEnabledFeaturesSiteFeaturesGet>>, TError> & { swrKey?: Key, enabled?: boolean }, request?: SecondParameter<typeof customInstance> }
) => {
  const {swr: swrOptions, request: requestOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getGetEnabledFeaturesSiteFeaturesGetKey() : null);
  const swrFn = () => getEnabledFeaturesSiteFeaturesGet(requestOptions)

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * Get the currently active theme information.

Returns the name and details of the active theme.
 * @summary Get Active Theme
 */
export const getActiveThemeSiteThemeGet = (
    
 options?: SecondParameter<typeof customInstance>) => {
    return customInstance<unknown>(
    {url: `/site/theme`, method: 'GET'
    },
    options);
  }



export const getGetActiveThemeSiteThemeGetKey = () => [`/site/theme`] as const;

export type GetActiveThemeSiteThemeGetQueryResult = NonNullable<Awaited<ReturnType<typeof getActiveThemeSiteThemeGet>>>
export type GetActiveThemeSiteThemeGetQueryError = unknown

/**
 * @summary Get Active Theme
 */
export const useGetActiveThemeSiteThemeGet = <TError = unknown>(
   options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof getActiveThemeSiteThemeGet>>, TError> & { swrKey?: Key, enabled?: boolean }, request?: SecondParameter<typeof customInstance> }
) => {
  const {swr: swrOptions, request: requestOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getGetActiveThemeSiteThemeGetKey() : null);
  const swrFn = () => getActiveThemeSiteThemeGet(requestOptions)

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * @summary Health Check
 */
export const healthCheckHealthGet = (
    
 options?: SecondParameter<typeof customInstance>) => {
    return customInstance<unknown>(
    {url: `/health`, method: 'GET'
    },
    options);
  }



export const getHealthCheckHealthGetKey = () => [`/health`] as const;

export type HealthCheckHealthGetQueryResult = NonNullable<Awaited<ReturnType<typeof healthCheckHealthGet>>>
export type HealthCheckHealthGetQueryError = unknown

/**
 * @summary Health Check
 */
export const useHealthCheckHealthGet = <TError = unknown>(
   options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof healthCheckHealthGet>>, TError> & { swrKey?: Key, enabled?: boolean }, request?: SecondParameter<typeof customInstance> }
) => {
  const {swr: swrOptions, request: requestOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getHealthCheckHealthGetKey() : null);
  const swrFn = () => healthCheckHealthGet(requestOptions)

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * @summary Root
 */
export const rootGet = (
    
 options?: SecondParameter<typeof customInstance>) => {
    return customInstance<unknown>(
    {url: `/`, method: 'GET'
    },
    options);
  }



export const getRootGetKey = () => [`/`] as const;

export type RootGetQueryResult = NonNullable<Awaited<ReturnType<typeof rootGet>>>
export type RootGetQueryError = unknown

/**
 * @summary Root
 */
export const useRootGet = <TError = unknown>(
   options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof rootGet>>, TError> & { swrKey?: Key, enabled?: boolean }, request?: SecondParameter<typeof customInstance> }
) => {
  const {swr: swrOptions, request: requestOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getRootGetKey() : null);
  const swrFn = () => rootGet(requestOptions)

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}
