/**
 * Generated by orval v7.11.2 üç∫
 * Do not edit manually.
 * Blog Backend API
 * A scalable blog backend built with FastAPI and SQLModel
 * OpenAPI spec version: 1.0.0
 */
import * as axios from 'axios';
import type {
  AxiosError,
  AxiosRequestConfig,
  AxiosResponse
} from 'axios';

import useSwr from 'swr';
import type {
  Arguments,
  Key,
  SWRConfiguration
} from 'swr';

import useSWRMutation from 'swr/mutation';
import type {
  SWRMutationConfiguration
} from 'swr/mutation';

/**
 * Associated post ID
 */
export type BodyUploadFilesUploadPostPostId = string | null;

export interface BodyUploadFilesUploadPost {
  files: Blob[];
  /** Associated post ID */
  post_id?: BodyUploadFilesUploadPostPostId;
}

export type CategoryCreateDescription = string | null;

/**
 * Model for category creation.
 */
export interface CategoryCreate {
  /** @maxLength 100 */
  name: string;
  /** @maxLength 100 */
  slug: string;
  description?: CategoryCreateDescription;
}

export type CategoryReadDescription = string | null;

/**
 * Model for category response.
 */
export interface CategoryRead {
  id: number;
  name: string;
  slug: string;
  description: CategoryReadDescription;
}

export type CategoryUpdateName = string | null;

export type CategoryUpdateSlug = string | null;

export type CategoryUpdateDescription = string | null;

/**
 * Model for category updates.
 */
export interface CategoryUpdate {
  name?: CategoryUpdateName;
  slug?: CategoryUpdateSlug;
  description?: CategoryUpdateDescription;
}

export type CommentCreateParentCommentId = string | null;

export type CommentCreateAuthorName = string | null;

export type CommentCreateAuthorEmail = string | null;

export type CommentCreateAuthorUrl = string | null;

/**
 * Model for comment creation.
 */
export interface CommentCreate {
  post_id: string;
  content: string;
  parent_comment_id?: CommentCreateParentCommentId;
  author_name?: CommentCreateAuthorName;
  author_email?: CommentCreateAuthorEmail;
  author_url?: CommentCreateAuthorUrl;
}

export type CommentReadAuthorId = string | null;

export type CommentReadAuthorName = string | null;

export type CommentReadAuthorEmail = string | null;

export type CommentReadAuthorUrl = string | null;

export type CommentReadParentCommentId = string | null;

/**
 * Model for comment response.
 */
export interface CommentRead {
  id: string;
  post_id: string;
  author_id: CommentReadAuthorId;
  author_name: CommentReadAuthorName;
  author_email: CommentReadAuthorEmail;
  author_url: CommentReadAuthorUrl;
  content: string;
  parent_comment_id: CommentReadParentCommentId;
  status: CommentStatus;
  created_at: string;
  updated_at: string;
}

/**
 * Comment status enumeration.
 */
export type CommentStatus = typeof CommentStatus[keyof typeof CommentStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CommentStatus = {
  pending: 'pending',
  approved: 'approved',
  rejected: 'rejected',
  spam: 'spam',
} as const;

export type CommentUpdateContent = string | null;

export type CommentUpdateStatus = CommentStatus | null;

/**
 * Model for comment updates.
 */
export interface CommentUpdate {
  content?: CommentUpdateContent;
  status?: CommentUpdateStatus;
}

export interface HTTPValidationError {
  detail?: ValidationError[];
}

/**
 * Model for like creation.
 */
export interface LikeCreate {
  post_id: string;
}

export type LikeReadUserId = string | null;

/**
 * Model for like response.
 */
export interface LikeRead {
  id: string;
  post_id: string;
  user_id: LikeReadUserId;
  created_at: string;
}

export type PostCreateTitle = string | null;

export type PostCreateContent = string | null;

export type PostCreateMarkdownContent = string | null;

export type PostCreateMediaUrl = string | null;

export type PostCreateLinkUrl = string | null;

/**
 * Model for post creation.
 */
export interface PostCreate {
  /** @maxLength 50 */
  feather_type: string;
  /** @maxLength 255 */
  slug: string;
  title?: PostCreateTitle;
  status?: PostStatus;
  is_private?: boolean;
  content?: PostCreateContent;
  markdown_content?: PostCreateMarkdownContent;
  media_url?: PostCreateMediaUrl;
  link_url?: PostCreateLinkUrl;
}

export type PostFileReadPostId = string | null;

export type PostFileReadDescription = string | null;

/**
 * Model for file response.
 */
export interface PostFileRead {
  id: string;
  post_id: PostFileReadPostId;
  filename: string;
  file_path: string;
  mime_type: string;
  file_size: number;
  description: PostFileReadDescription;
  created_at: string;
  updated_at: string;
}

export type PostReadTitle = string | null;

export type PostReadPublishedAt = string | null;

export type PostReadCategoriesItem = { [key: string]: unknown };

export type PostReadTagsItem = { [key: string]: unknown };

export type PostReadContent = string | null;

export type PostReadExcerpt = string | null;

/**
 * Model for post response.
 */
export interface PostRead {
  id: string;
  author_id: string;
  feather_type: string;
  slug: string;
  title: PostReadTitle;
  status: PostStatus;
  published_at: PostReadPublishedAt;
  is_private: boolean;
  view_count: number;
  created_at: string;
  updated_at: string;
  categories?: PostReadCategoriesItem[];
  tags?: PostReadTagsItem[];
  likes_count?: number;
  content?: PostReadContent;
  excerpt?: PostReadExcerpt;
}

/**
 * Post status enumeration.
 */
export type PostStatus = typeof PostStatus[keyof typeof PostStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PostStatus = {
  draft: 'draft',
  published: 'published',
  scheduled: 'scheduled',
  private: 'private',
} as const;

export type PostUpdateTitle = string | null;

export type PostUpdateStatus = PostStatus | null;

export type PostUpdateIsPrivate = boolean | null;

export type PostUpdateContent = string | null;

export type PostUpdateMarkdownContent = string | null;

/**
 * Model for post updates.
 */
export interface PostUpdate {
  title?: PostUpdateTitle;
  status?: PostUpdateStatus;
  is_private?: PostUpdateIsPrivate;
  content?: PostUpdateContent;
  markdown_content?: PostUpdateMarkdownContent;
}

/**
 * Model for tag creation.
 */
export interface TagCreate {
  /** @maxLength 100 */
  name: string;
  /** @maxLength 100 */
  slug: string;
}

/**
 * Model for tag response.
 */
export interface TagRead {
  id: number;
  name: string;
  slug: string;
}

export type ThemeReadVersion = string | null;

export type ThemeReadAuthor = string | null;

/**
 * Model for theme response.
 */
export interface ThemeRead {
  id: number;
  name: string;
  slug: string;
  version: ThemeReadVersion;
  author: ThemeReadAuthor;
  is_active: boolean;
}

export type UserCreateDisplayName = string | null;

export type UserCreateBio = string | null;

/**
 * Model for user creation.
 */
export interface UserCreate {
  /** @maxLength 50 */
  username: string;
  /** @maxLength 255 */
  email: string;
  /** @minLength 8 */
  password: string;
  display_name?: UserCreateDisplayName;
  bio?: UserCreateBio;
}

/**
 * Model for user login.
 */
export interface UserLogin {
  username: string;
  password: string;
}

export type UserReadDisplayName = string | null;

export type UserReadBio = string | null;

export type UserReadAvatarUrl = string | null;

/**
 * Model for user response (without sensitive data).
 */
export interface UserRead {
  id: string;
  username: string;
  email: string;
  display_name: UserReadDisplayName;
  bio: UserReadBio;
  avatar_url: UserReadAvatarUrl;
  created_at: string;
  updated_at: string;
}

export type UserUpdateDisplayName = string | null;

export type UserUpdateBio = string | null;

export type UserUpdateAvatarUrl = string | null;

/**
 * Model for user updates.
 */
export interface UserUpdate {
  display_name?: UserUpdateDisplayName;
  bio?: UserUpdateBio;
  avatar_url?: UserUpdateAvatarUrl;
}

export type ValidationErrorLocItem = string | number;

export interface ValidationError {
  loc: ValidationErrorLocItem[];
  msg: string;
  type: string;
}

export type ListUsersUsersGetParams = {
/**
 * @minimum 0
 */
skip?: number;
/**
 * @minimum 1
 * @maximum 100
 */
limit?: number;
};

export type ListPostsPostsGetParams = {
/**
 * Number of posts to skip
 * @minimum 0
 */
skip?: number;
/**
 * Number of posts to return
 * @minimum 1
 * @maximum 100
 */
limit?: number;
/**
 * Filter by category slug
 */
category?: string | null;
/**
 * Filter by tag slug
 */
tag?: string | null;
/**
 * Search in title and content
 */
search?: string | null;
/**
 * Filter by post status
 */
status?: string | null;
/**
 * Filter by author ID
 */
author_id?: string | null;
};

export type ListCategoriesCategoriesGetParams = {
/**
 * @minimum 0
 */
skip?: number;
/**
 * @minimum 1
 * @maximum 100
 */
limit?: number;
};

export type ListTagsTagsGetParams = {
/**
 * @minimum 0
 */
skip?: number;
/**
 * @minimum 1
 * @maximum 100
 */
limit?: number;
search?: string | null;
};

export type ListPostCommentsPostsPostIdCommentsGetParams = {
/**
 * @minimum 0
 */
skip?: number;
/**
 * @minimum 1
 * @maximum 100
 */
limit?: number;
};

export type ListPostLikesPostsPostIdLikesGetParams = {
/**
 * @minimum 0
 */
skip?: number;
/**
 * @minimum 1
 * @maximum 100
 */
limit?: number;
};

export type ListFilesUploadGetParams = {
/**
 * Filter by post ID
 */
post_id?: string | null;
/**
 * Number of files to skip
 * @minimum 0
 */
skip?: number;
/**
 * Number of files to return
 * @minimum 1
 * @maximum 100
 */
limit?: number;
};

/**
 * Register a new user.
 * @summary Register
 */
export const registerAuthRegisterPost = (
    userCreate: UserCreate, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UserRead>> => {
    return axios.default.post(
      `http://100.109.46.43:8007/auth/register`,
      userCreate,options
    );
  }



export const getRegisterAuthRegisterPostMutationFetcher = ( options?: AxiosRequestConfig) => {
  return (_: Key, { arg }: { arg: UserCreate }): Promise<AxiosResponse<UserRead>> => {
    return registerAuthRegisterPost(arg, options);
  }
}
export const getRegisterAuthRegisterPostMutationKey = () => [`http://100.109.46.43:8007/auth/register`] as const;

export type RegisterAuthRegisterPostMutationResult = NonNullable<Awaited<ReturnType<typeof registerAuthRegisterPost>>>
export type RegisterAuthRegisterPostMutationError = AxiosError<HTTPValidationError>

/**
 * @summary Register
 */
export const useRegisterAuthRegisterPost = <TError = AxiosError<HTTPValidationError>>(
   options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof registerAuthRegisterPost>>, TError, Key, UserCreate, Awaited<ReturnType<typeof registerAuthRegisterPost>>> & { swrKey?: string }, axios?: AxiosRequestConfig}
) => {

  const {swr: swrOptions, axios: axiosOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getRegisterAuthRegisterPostMutationKey();
  const swrFn = getRegisterAuthRegisterPostMutationFetcher(axiosOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * Login user and create session.
 * @summary Login
 */
export const loginAuthLoginPost = (
    userLogin: UserLogin, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    return axios.default.post(
      `http://100.109.46.43:8007/auth/login`,
      userLogin,options
    );
  }



export const getLoginAuthLoginPostMutationFetcher = ( options?: AxiosRequestConfig) => {
  return (_: Key, { arg }: { arg: UserLogin }): Promise<AxiosResponse<unknown>> => {
    return loginAuthLoginPost(arg, options);
  }
}
export const getLoginAuthLoginPostMutationKey = () => [`http://100.109.46.43:8007/auth/login`] as const;

export type LoginAuthLoginPostMutationResult = NonNullable<Awaited<ReturnType<typeof loginAuthLoginPost>>>
export type LoginAuthLoginPostMutationError = AxiosError<HTTPValidationError>

/**
 * @summary Login
 */
export const useLoginAuthLoginPost = <TError = AxiosError<HTTPValidationError>>(
   options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof loginAuthLoginPost>>, TError, Key, UserLogin, Awaited<ReturnType<typeof loginAuthLoginPost>>> & { swrKey?: string }, axios?: AxiosRequestConfig}
) => {

  const {swr: swrOptions, axios: axiosOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getLoginAuthLoginPostMutationKey();
  const swrFn = getLoginAuthLoginPostMutationFetcher(axiosOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * Logout user and delete session.
 * @summary Logout
 */
export const logoutAuthLogoutPost = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    return axios.default.post(
      `http://100.109.46.43:8007/auth/logout`,undefined,options
    );
  }



export const getLogoutAuthLogoutPostMutationFetcher = ( options?: AxiosRequestConfig) => {
  return (_: Key, __: { arg: Arguments }): Promise<AxiosResponse<unknown>> => {
    return logoutAuthLogoutPost(options);
  }
}
export const getLogoutAuthLogoutPostMutationKey = () => [`http://100.109.46.43:8007/auth/logout`] as const;

export type LogoutAuthLogoutPostMutationResult = NonNullable<Awaited<ReturnType<typeof logoutAuthLogoutPost>>>
export type LogoutAuthLogoutPostMutationError = AxiosError<unknown>

/**
 * @summary Logout
 */
export const useLogoutAuthLogoutPost = <TError = AxiosError<unknown>>(
   options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof logoutAuthLogoutPost>>, TError, Key, Arguments, Awaited<ReturnType<typeof logoutAuthLogoutPost>>> & { swrKey?: string }, axios?: AxiosRequestConfig}
) => {

  const {swr: swrOptions, axios: axiosOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getLogoutAuthLogoutPostMutationKey();
  const swrFn = getLogoutAuthLogoutPostMutationFetcher(axiosOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * Get current user information.
 * @summary Get Current User Info
 */
export const getCurrentUserInfoAuthMeGet = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UserRead>> => {
    return axios.default.get(
      `http://100.109.46.43:8007/auth/me`,options
    );
  }



export const getGetCurrentUserInfoAuthMeGetKey = () => [`http://100.109.46.43:8007/auth/me`] as const;

export type GetCurrentUserInfoAuthMeGetQueryResult = NonNullable<Awaited<ReturnType<typeof getCurrentUserInfoAuthMeGet>>>
export type GetCurrentUserInfoAuthMeGetQueryError = AxiosError<unknown>

/**
 * @summary Get Current User Info
 */
export const useGetCurrentUserInfoAuthMeGet = <TError = AxiosError<unknown>>(
   options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof getCurrentUserInfoAuthMeGet>>, TError> & { swrKey?: Key, enabled?: boolean }, axios?: AxiosRequestConfig }
) => {
  const {swr: swrOptions, axios: axiosOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getGetCurrentUserInfoAuthMeGetKey() : null);
  const swrFn = () => getCurrentUserInfoAuthMeGet(axiosOptions)

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * Logout from all sessions.
 * @summary Logout All Sessions
 */
export const logoutAllSessionsAuthLogoutAllPost = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    return axios.default.post(
      `http://100.109.46.43:8007/auth/logout-all`,undefined,options
    );
  }



export const getLogoutAllSessionsAuthLogoutAllPostMutationFetcher = ( options?: AxiosRequestConfig) => {
  return (_: Key, __: { arg: Arguments }): Promise<AxiosResponse<unknown>> => {
    return logoutAllSessionsAuthLogoutAllPost(options);
  }
}
export const getLogoutAllSessionsAuthLogoutAllPostMutationKey = () => [`http://100.109.46.43:8007/auth/logout-all`] as const;

export type LogoutAllSessionsAuthLogoutAllPostMutationResult = NonNullable<Awaited<ReturnType<typeof logoutAllSessionsAuthLogoutAllPost>>>
export type LogoutAllSessionsAuthLogoutAllPostMutationError = AxiosError<unknown>

/**
 * @summary Logout All Sessions
 */
export const useLogoutAllSessionsAuthLogoutAllPost = <TError = AxiosError<unknown>>(
   options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof logoutAllSessionsAuthLogoutAllPost>>, TError, Key, Arguments, Awaited<ReturnType<typeof logoutAllSessionsAuthLogoutAllPost>>> & { swrKey?: string }, axios?: AxiosRequestConfig}
) => {

  const {swr: swrOptions, axios: axiosOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getLogoutAllSessionsAuthLogoutAllPostMutationKey();
  const swrFn = getLogoutAllSessionsAuthLogoutAllPostMutationFetcher(axiosOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * List users with pagination.
 * @summary List Users
 */
export const listUsersUsersGet = (
    params?: ListUsersUsersGetParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UserRead[]>> => {
    return axios.default.get(
      `http://100.109.46.43:8007/users/`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }



export const getListUsersUsersGetKey = (params?: ListUsersUsersGetParams,) => [`http://100.109.46.43:8007/users/`, ...(params ? [params]: [])] as const;

export type ListUsersUsersGetQueryResult = NonNullable<Awaited<ReturnType<typeof listUsersUsersGet>>>
export type ListUsersUsersGetQueryError = AxiosError<HTTPValidationError>

/**
 * @summary List Users
 */
export const useListUsersUsersGet = <TError = AxiosError<HTTPValidationError>>(
  params?: ListUsersUsersGetParams, options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof listUsersUsersGet>>, TError> & { swrKey?: Key, enabled?: boolean }, axios?: AxiosRequestConfig }
) => {
  const {swr: swrOptions, axios: axiosOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getListUsersUsersGetKey(params) : null);
  const swrFn = () => listUsersUsersGet(params, axiosOptions)

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * Get user by ID.
 * @summary Get User
 */
export const getUserUsersUserIdGet = (
    userId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UserRead>> => {
    return axios.default.get(
      `http://100.109.46.43:8007/users/${userId}`,options
    );
  }



export const getGetUserUsersUserIdGetKey = (userId: string,) => [`http://100.109.46.43:8007/users/${userId}`] as const;

export type GetUserUsersUserIdGetQueryResult = NonNullable<Awaited<ReturnType<typeof getUserUsersUserIdGet>>>
export type GetUserUsersUserIdGetQueryError = AxiosError<HTTPValidationError>

/**
 * @summary Get User
 */
export const useGetUserUsersUserIdGet = <TError = AxiosError<HTTPValidationError>>(
  userId: string, options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof getUserUsersUserIdGet>>, TError> & { swrKey?: Key, enabled?: boolean }, axios?: AxiosRequestConfig }
) => {
  const {swr: swrOptions, axios: axiosOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false && !!(userId)
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getGetUserUsersUserIdGetKey(userId) : null);
  const swrFn = () => getUserUsersUserIdGet(userId, axiosOptions)

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * Update user (only own profile or admin).
 * @summary Update User
 */
export const updateUserUsersUserIdPut = (
    userId: string,
    userUpdate: UserUpdate, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UserRead>> => {
    return axios.default.put(
      `http://100.109.46.43:8007/users/${userId}`,
      userUpdate,options
    );
  }



export const getUpdateUserUsersUserIdPutMutationFetcher = (userId: string, options?: AxiosRequestConfig) => {
  return (_: Key, { arg }: { arg: UserUpdate }): Promise<AxiosResponse<UserRead>> => {
    return updateUserUsersUserIdPut(userId, arg, options);
  }
}
export const getUpdateUserUsersUserIdPutMutationKey = (userId: string,) => [`http://100.109.46.43:8007/users/${userId}`] as const;

export type UpdateUserUsersUserIdPutMutationResult = NonNullable<Awaited<ReturnType<typeof updateUserUsersUserIdPut>>>
export type UpdateUserUsersUserIdPutMutationError = AxiosError<HTTPValidationError>

/**
 * @summary Update User
 */
export const useUpdateUserUsersUserIdPut = <TError = AxiosError<HTTPValidationError>>(
  userId: string, options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof updateUserUsersUserIdPut>>, TError, Key, UserUpdate, Awaited<ReturnType<typeof updateUserUsersUserIdPut>>> & { swrKey?: string }, axios?: AxiosRequestConfig}
) => {

  const {swr: swrOptions, axios: axiosOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getUpdateUserUsersUserIdPutMutationKey(userId);
  const swrFn = getUpdateUserUsersUserIdPutMutationFetcher(userId, axiosOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * Delete user (only own profile or admin).
 * @summary Delete User
 */
export const deleteUserUsersUserIdDelete = (
    userId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    return axios.default.delete(
      `http://100.109.46.43:8007/users/${userId}`,options
    );
  }



export const getDeleteUserUsersUserIdDeleteMutationFetcher = (userId: string, options?: AxiosRequestConfig) => {
  return (_: Key, __: { arg: Arguments }): Promise<AxiosResponse<unknown>> => {
    return deleteUserUsersUserIdDelete(userId, options);
  }
}
export const getDeleteUserUsersUserIdDeleteMutationKey = (userId: string,) => [`http://100.109.46.43:8007/users/${userId}`] as const;

export type DeleteUserUsersUserIdDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof deleteUserUsersUserIdDelete>>>
export type DeleteUserUsersUserIdDeleteMutationError = AxiosError<HTTPValidationError>

/**
 * @summary Delete User
 */
export const useDeleteUserUsersUserIdDelete = <TError = AxiosError<HTTPValidationError>>(
  userId: string, options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof deleteUserUsersUserIdDelete>>, TError, Key, Arguments, Awaited<ReturnType<typeof deleteUserUsersUserIdDelete>>> & { swrKey?: string }, axios?: AxiosRequestConfig}
) => {

  const {swr: swrOptions, axios: axiosOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getDeleteUserUsersUserIdDeleteMutationKey(userId);
  const swrFn = getDeleteUserUsersUserIdDeleteMutationFetcher(userId, axiosOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * List all posts with pagination and filtering.

Returns posts with joined categories, tags, likes, and view counts.
Private/draft posts are only visible to authenticated users.
 * @summary List Posts
 */
export const listPostsPostsGet = (
    params?: ListPostsPostsGetParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PostRead[]>> => {
    return axios.default.get(
      `http://100.109.46.43:8007/posts`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }



export const getListPostsPostsGetKey = (params?: ListPostsPostsGetParams,) => [`http://100.109.46.43:8007/posts`, ...(params ? [params]: [])] as const;

export type ListPostsPostsGetQueryResult = NonNullable<Awaited<ReturnType<typeof listPostsPostsGet>>>
export type ListPostsPostsGetQueryError = AxiosError<HTTPValidationError>

/**
 * @summary List Posts
 */
export const useListPostsPostsGet = <TError = AxiosError<HTTPValidationError>>(
  params?: ListPostsPostsGetParams, options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof listPostsPostsGet>>, TError> & { swrKey?: Key, enabled?: boolean }, axios?: AxiosRequestConfig }
) => {
  const {swr: swrOptions, axios: axiosOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getListPostsPostsGetKey(params) : null);
  const swrFn = () => listPostsPostsGet(params, axiosOptions)

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * Create a new post.

Supports all post types: text, quote, link, photo, audio, video.
Requires authentication.
 * @summary Create Post
 */
export const createPostPostsPost = (
    postCreate: PostCreate, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PostRead>> => {
    return axios.default.post(
      `http://100.109.46.43:8007/posts`,
      postCreate,options
    );
  }



export const getCreatePostPostsPostMutationFetcher = ( options?: AxiosRequestConfig) => {
  return (_: Key, { arg }: { arg: PostCreate }): Promise<AxiosResponse<PostRead>> => {
    return createPostPostsPost(arg, options);
  }
}
export const getCreatePostPostsPostMutationKey = () => [`http://100.109.46.43:8007/posts`] as const;

export type CreatePostPostsPostMutationResult = NonNullable<Awaited<ReturnType<typeof createPostPostsPost>>>
export type CreatePostPostsPostMutationError = AxiosError<HTTPValidationError>

/**
 * @summary Create Post
 */
export const useCreatePostPostsPost = <TError = AxiosError<HTTPValidationError>>(
   options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof createPostPostsPost>>, TError, Key, PostCreate, Awaited<ReturnType<typeof createPostPostsPost>>> & { swrKey?: string }, axios?: AxiosRequestConfig}
) => {

  const {swr: swrOptions, axios: axiosOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getCreatePostPostsPostMutationKey();
  const swrFn = getCreatePostPostsPostMutationFetcher(axiosOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * Get single post details with categories, tags, likes, and view count.

Increments view count for public posts.
Private/draft posts require authentication.
 * @summary Get Post
 */
export const getPostPostsPostIdGet = (
    postId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PostRead>> => {
    return axios.default.get(
      `http://100.109.46.43:8007/posts/${postId}`,options
    );
  }



export const getGetPostPostsPostIdGetKey = (postId: string,) => [`http://100.109.46.43:8007/posts/${postId}`] as const;

export type GetPostPostsPostIdGetQueryResult = NonNullable<Awaited<ReturnType<typeof getPostPostsPostIdGet>>>
export type GetPostPostsPostIdGetQueryError = AxiosError<HTTPValidationError>

/**
 * @summary Get Post
 */
export const useGetPostPostsPostIdGet = <TError = AxiosError<HTTPValidationError>>(
  postId: string, options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof getPostPostsPostIdGet>>, TError> & { swrKey?: Key, enabled?: boolean }, axios?: AxiosRequestConfig }
) => {
  const {swr: swrOptions, axios: axiosOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false && !!(postId)
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getGetPostPostsPostIdGetKey(postId) : null);
  const swrFn = () => getPostPostsPostIdGet(postId, axiosOptions)

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * Update an existing post.

Only the author or users with appropriate permissions can update posts.
 * @summary Update Post
 */
export const updatePostPostsPostIdPut = (
    postId: string,
    postUpdate: PostUpdate, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PostRead>> => {
    return axios.default.put(
      `http://100.109.46.43:8007/posts/${postId}`,
      postUpdate,options
    );
  }



export const getUpdatePostPostsPostIdPutMutationFetcher = (postId: string, options?: AxiosRequestConfig) => {
  return (_: Key, { arg }: { arg: PostUpdate }): Promise<AxiosResponse<PostRead>> => {
    return updatePostPostsPostIdPut(postId, arg, options);
  }
}
export const getUpdatePostPostsPostIdPutMutationKey = (postId: string,) => [`http://100.109.46.43:8007/posts/${postId}`] as const;

export type UpdatePostPostsPostIdPutMutationResult = NonNullable<Awaited<ReturnType<typeof updatePostPostsPostIdPut>>>
export type UpdatePostPostsPostIdPutMutationError = AxiosError<HTTPValidationError>

/**
 * @summary Update Post
 */
export const useUpdatePostPostsPostIdPut = <TError = AxiosError<HTTPValidationError>>(
  postId: string, options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof updatePostPostsPostIdPut>>, TError, Key, PostUpdate, Awaited<ReturnType<typeof updatePostPostsPostIdPut>>> & { swrKey?: string }, axios?: AxiosRequestConfig}
) => {

  const {swr: swrOptions, axios: axiosOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getUpdatePostPostsPostIdPutMutationKey(postId);
  const swrFn = getUpdatePostPostsPostIdPutMutationFetcher(postId, axiosOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * Delete a post.

Only the author or users with appropriate permissions can delete posts.
 * @summary Delete Post
 */
export const deletePostPostsPostIdDelete = (
    postId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<null>> => {
    return axios.default.delete(
      `http://100.109.46.43:8007/posts/${postId}`,options
    );
  }



export const getDeletePostPostsPostIdDeleteMutationFetcher = (postId: string, options?: AxiosRequestConfig) => {
  return (_: Key, __: { arg: Arguments }): Promise<AxiosResponse<null>> => {
    return deletePostPostsPostIdDelete(postId, options);
  }
}
export const getDeletePostPostsPostIdDeleteMutationKey = (postId: string,) => [`http://100.109.46.43:8007/posts/${postId}`] as const;

export type DeletePostPostsPostIdDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof deletePostPostsPostIdDelete>>>
export type DeletePostPostsPostIdDeleteMutationError = AxiosError<HTTPValidationError>

/**
 * @summary Delete Post
 */
export const useDeletePostPostsPostIdDelete = <TError = AxiosError<HTTPValidationError>>(
  postId: string, options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof deletePostPostsPostIdDelete>>, TError, Key, Arguments, Awaited<ReturnType<typeof deletePostPostsPostIdDelete>>> & { swrKey?: string }, axios?: AxiosRequestConfig}
) => {

  const {swr: swrOptions, axios: axiosOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getDeletePostPostsPostIdDeleteMutationKey(postId);
  const swrFn = getDeletePostPostsPostIdDeleteMutationFetcher(postId, axiosOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * Like a post.

Creates a like entry if not already liked by the user.
 * @summary Like Post
 */
export const likePostPostsPostIdLikePost = (
    postId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    return axios.default.post(
      `http://100.109.46.43:8007/posts/${postId}/like`,undefined,options
    );
  }



export const getLikePostPostsPostIdLikePostMutationFetcher = (postId: string, options?: AxiosRequestConfig) => {
  return (_: Key, __: { arg: Arguments }): Promise<AxiosResponse<unknown>> => {
    return likePostPostsPostIdLikePost(postId, options);
  }
}
export const getLikePostPostsPostIdLikePostMutationKey = (postId: string,) => [`http://100.109.46.43:8007/posts/${postId}/like`] as const;

export type LikePostPostsPostIdLikePostMutationResult = NonNullable<Awaited<ReturnType<typeof likePostPostsPostIdLikePost>>>
export type LikePostPostsPostIdLikePostMutationError = AxiosError<HTTPValidationError>

/**
 * @summary Like Post
 */
export const useLikePostPostsPostIdLikePost = <TError = AxiosError<HTTPValidationError>>(
  postId: string, options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof likePostPostsPostIdLikePost>>, TError, Key, Arguments, Awaited<ReturnType<typeof likePostPostsPostIdLikePost>>> & { swrKey?: string }, axios?: AxiosRequestConfig}
) => {

  const {swr: swrOptions, axios: axiosOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getLikePostPostsPostIdLikePostMutationKey(postId);
  const swrFn = getLikePostPostsPostIdLikePostMutationFetcher(postId, axiosOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * Unlike a post.

Removes the like entry if it exists.
 * @summary Unlike Post
 */
export const unlikePostPostsPostIdLikeDelete = (
    postId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<null>> => {
    return axios.default.delete(
      `http://100.109.46.43:8007/posts/${postId}/like`,options
    );
  }



export const getUnlikePostPostsPostIdLikeDeleteMutationFetcher = (postId: string, options?: AxiosRequestConfig) => {
  return (_: Key, __: { arg: Arguments }): Promise<AxiosResponse<null>> => {
    return unlikePostPostsPostIdLikeDelete(postId, options);
  }
}
export const getUnlikePostPostsPostIdLikeDeleteMutationKey = (postId: string,) => [`http://100.109.46.43:8007/posts/${postId}/like`] as const;

export type UnlikePostPostsPostIdLikeDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof unlikePostPostsPostIdLikeDelete>>>
export type UnlikePostPostsPostIdLikeDeleteMutationError = AxiosError<HTTPValidationError>

/**
 * @summary Unlike Post
 */
export const useUnlikePostPostsPostIdLikeDelete = <TError = AxiosError<HTTPValidationError>>(
  postId: string, options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof unlikePostPostsPostIdLikeDelete>>, TError, Key, Arguments, Awaited<ReturnType<typeof unlikePostPostsPostIdLikeDelete>>> & { swrKey?: string }, axios?: AxiosRequestConfig}
) => {

  const {swr: swrOptions, axios: axiosOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getUnlikePostPostsPostIdLikeDeleteMutationKey(postId);
  const swrFn = getUnlikePostPostsPostIdLikeDeleteMutationFetcher(postId, axiosOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * Create a new category.
 * @summary Create Category
 */
export const createCategoryCategoriesPost = (
    categoryCreate: CategoryCreate, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CategoryRead>> => {
    return axios.default.post(
      `http://100.109.46.43:8007/categories/`,
      categoryCreate,options
    );
  }



export const getCreateCategoryCategoriesPostMutationFetcher = ( options?: AxiosRequestConfig) => {
  return (_: Key, { arg }: { arg: CategoryCreate }): Promise<AxiosResponse<CategoryRead>> => {
    return createCategoryCategoriesPost(arg, options);
  }
}
export const getCreateCategoryCategoriesPostMutationKey = () => [`http://100.109.46.43:8007/categories/`] as const;

export type CreateCategoryCategoriesPostMutationResult = NonNullable<Awaited<ReturnType<typeof createCategoryCategoriesPost>>>
export type CreateCategoryCategoriesPostMutationError = AxiosError<HTTPValidationError>

/**
 * @summary Create Category
 */
export const useCreateCategoryCategoriesPost = <TError = AxiosError<HTTPValidationError>>(
   options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof createCategoryCategoriesPost>>, TError, Key, CategoryCreate, Awaited<ReturnType<typeof createCategoryCategoriesPost>>> & { swrKey?: string }, axios?: AxiosRequestConfig}
) => {

  const {swr: swrOptions, axios: axiosOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getCreateCategoryCategoriesPostMutationKey();
  const swrFn = getCreateCategoryCategoriesPostMutationFetcher(axiosOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * List all categories with pagination.
 * @summary List Categories
 */
export const listCategoriesCategoriesGet = (
    params?: ListCategoriesCategoriesGetParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CategoryRead[]>> => {
    return axios.default.get(
      `http://100.109.46.43:8007/categories/`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }



export const getListCategoriesCategoriesGetKey = (params?: ListCategoriesCategoriesGetParams,) => [`http://100.109.46.43:8007/categories/`, ...(params ? [params]: [])] as const;

export type ListCategoriesCategoriesGetQueryResult = NonNullable<Awaited<ReturnType<typeof listCategoriesCategoriesGet>>>
export type ListCategoriesCategoriesGetQueryError = AxiosError<HTTPValidationError>

/**
 * @summary List Categories
 */
export const useListCategoriesCategoriesGet = <TError = AxiosError<HTTPValidationError>>(
  params?: ListCategoriesCategoriesGetParams, options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof listCategoriesCategoriesGet>>, TError> & { swrKey?: Key, enabled?: boolean }, axios?: AxiosRequestConfig }
) => {
  const {swr: swrOptions, axios: axiosOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getListCategoriesCategoriesGetKey(params) : null);
  const swrFn = () => listCategoriesCategoriesGet(params, axiosOptions)

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * Get category by ID.
 * @summary Get Category
 */
export const getCategoryCategoriesCategoryIdGet = (
    categoryId: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CategoryRead>> => {
    return axios.default.get(
      `http://100.109.46.43:8007/categories/${categoryId}`,options
    );
  }



export const getGetCategoryCategoriesCategoryIdGetKey = (categoryId: number,) => [`http://100.109.46.43:8007/categories/${categoryId}`] as const;

export type GetCategoryCategoriesCategoryIdGetQueryResult = NonNullable<Awaited<ReturnType<typeof getCategoryCategoriesCategoryIdGet>>>
export type GetCategoryCategoriesCategoryIdGetQueryError = AxiosError<HTTPValidationError>

/**
 * @summary Get Category
 */
export const useGetCategoryCategoriesCategoryIdGet = <TError = AxiosError<HTTPValidationError>>(
  categoryId: number, options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof getCategoryCategoriesCategoryIdGet>>, TError> & { swrKey?: Key, enabled?: boolean }, axios?: AxiosRequestConfig }
) => {
  const {swr: swrOptions, axios: axiosOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false && !!(categoryId)
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getGetCategoryCategoriesCategoryIdGetKey(categoryId) : null);
  const swrFn = () => getCategoryCategoriesCategoryIdGet(categoryId, axiosOptions)

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * Update category (authenticated users only).
 * @summary Update Category
 */
export const updateCategoryCategoriesCategoryIdPut = (
    categoryId: number,
    categoryUpdate: CategoryUpdate, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CategoryRead>> => {
    return axios.default.put(
      `http://100.109.46.43:8007/categories/${categoryId}`,
      categoryUpdate,options
    );
  }



export const getUpdateCategoryCategoriesCategoryIdPutMutationFetcher = (categoryId: number, options?: AxiosRequestConfig) => {
  return (_: Key, { arg }: { arg: CategoryUpdate }): Promise<AxiosResponse<CategoryRead>> => {
    return updateCategoryCategoriesCategoryIdPut(categoryId, arg, options);
  }
}
export const getUpdateCategoryCategoriesCategoryIdPutMutationKey = (categoryId: number,) => [`http://100.109.46.43:8007/categories/${categoryId}`] as const;

export type UpdateCategoryCategoriesCategoryIdPutMutationResult = NonNullable<Awaited<ReturnType<typeof updateCategoryCategoriesCategoryIdPut>>>
export type UpdateCategoryCategoriesCategoryIdPutMutationError = AxiosError<HTTPValidationError>

/**
 * @summary Update Category
 */
export const useUpdateCategoryCategoriesCategoryIdPut = <TError = AxiosError<HTTPValidationError>>(
  categoryId: number, options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof updateCategoryCategoriesCategoryIdPut>>, TError, Key, CategoryUpdate, Awaited<ReturnType<typeof updateCategoryCategoriesCategoryIdPut>>> & { swrKey?: string }, axios?: AxiosRequestConfig}
) => {

  const {swr: swrOptions, axios: axiosOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getUpdateCategoryCategoriesCategoryIdPutMutationKey(categoryId);
  const swrFn = getUpdateCategoryCategoriesCategoryIdPutMutationFetcher(categoryId, axiosOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * Delete category (authenticated users only).
 * @summary Delete Category
 */
export const deleteCategoryCategoriesCategoryIdDelete = (
    categoryId: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    return axios.default.delete(
      `http://100.109.46.43:8007/categories/${categoryId}`,options
    );
  }



export const getDeleteCategoryCategoriesCategoryIdDeleteMutationFetcher = (categoryId: number, options?: AxiosRequestConfig) => {
  return (_: Key, __: { arg: Arguments }): Promise<AxiosResponse<unknown>> => {
    return deleteCategoryCategoriesCategoryIdDelete(categoryId, options);
  }
}
export const getDeleteCategoryCategoriesCategoryIdDeleteMutationKey = (categoryId: number,) => [`http://100.109.46.43:8007/categories/${categoryId}`] as const;

export type DeleteCategoryCategoriesCategoryIdDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof deleteCategoryCategoriesCategoryIdDelete>>>
export type DeleteCategoryCategoriesCategoryIdDeleteMutationError = AxiosError<HTTPValidationError>

/**
 * @summary Delete Category
 */
export const useDeleteCategoryCategoriesCategoryIdDelete = <TError = AxiosError<HTTPValidationError>>(
  categoryId: number, options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof deleteCategoryCategoriesCategoryIdDelete>>, TError, Key, Arguments, Awaited<ReturnType<typeof deleteCategoryCategoriesCategoryIdDelete>>> & { swrKey?: string }, axios?: AxiosRequestConfig}
) => {

  const {swr: swrOptions, axios: axiosOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getDeleteCategoryCategoriesCategoryIdDeleteMutationKey(categoryId);
  const swrFn = getDeleteCategoryCategoriesCategoryIdDeleteMutationFetcher(categoryId, axiosOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * Create a new tag.
 * @summary Create Tag
 */
export const createTagTagsPost = (
    tagCreate: TagCreate, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<TagRead>> => {
    return axios.default.post(
      `http://100.109.46.43:8007/tags/`,
      tagCreate,options
    );
  }



export const getCreateTagTagsPostMutationFetcher = ( options?: AxiosRequestConfig) => {
  return (_: Key, { arg }: { arg: TagCreate }): Promise<AxiosResponse<TagRead>> => {
    return createTagTagsPost(arg, options);
  }
}
export const getCreateTagTagsPostMutationKey = () => [`http://100.109.46.43:8007/tags/`] as const;

export type CreateTagTagsPostMutationResult = NonNullable<Awaited<ReturnType<typeof createTagTagsPost>>>
export type CreateTagTagsPostMutationError = AxiosError<HTTPValidationError>

/**
 * @summary Create Tag
 */
export const useCreateTagTagsPost = <TError = AxiosError<HTTPValidationError>>(
   options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof createTagTagsPost>>, TError, Key, TagCreate, Awaited<ReturnType<typeof createTagTagsPost>>> & { swrKey?: string }, axios?: AxiosRequestConfig}
) => {

  const {swr: swrOptions, axios: axiosOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getCreateTagTagsPostMutationKey();
  const swrFn = getCreateTagTagsPostMutationFetcher(axiosOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * List all tags with pagination and optional search.
 * @summary List Tags
 */
export const listTagsTagsGet = (
    params?: ListTagsTagsGetParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<TagRead[]>> => {
    return axios.default.get(
      `http://100.109.46.43:8007/tags/`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }



export const getListTagsTagsGetKey = (params?: ListTagsTagsGetParams,) => [`http://100.109.46.43:8007/tags/`, ...(params ? [params]: [])] as const;

export type ListTagsTagsGetQueryResult = NonNullable<Awaited<ReturnType<typeof listTagsTagsGet>>>
export type ListTagsTagsGetQueryError = AxiosError<HTTPValidationError>

/**
 * @summary List Tags
 */
export const useListTagsTagsGet = <TError = AxiosError<HTTPValidationError>>(
  params?: ListTagsTagsGetParams, options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof listTagsTagsGet>>, TError> & { swrKey?: Key, enabled?: boolean }, axios?: AxiosRequestConfig }
) => {
  const {swr: swrOptions, axios: axiosOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getListTagsTagsGetKey(params) : null);
  const swrFn = () => listTagsTagsGet(params, axiosOptions)

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * Delete tag (authenticated users only).
 * @summary Delete Tag
 */
export const deleteTagTagsTagIdDelete = (
    tagId: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    return axios.default.delete(
      `http://100.109.46.43:8007/tags/${tagId}`,options
    );
  }



export const getDeleteTagTagsTagIdDeleteMutationFetcher = (tagId: number, options?: AxiosRequestConfig) => {
  return (_: Key, __: { arg: Arguments }): Promise<AxiosResponse<unknown>> => {
    return deleteTagTagsTagIdDelete(tagId, options);
  }
}
export const getDeleteTagTagsTagIdDeleteMutationKey = (tagId: number,) => [`http://100.109.46.43:8007/tags/${tagId}`] as const;

export type DeleteTagTagsTagIdDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof deleteTagTagsTagIdDelete>>>
export type DeleteTagTagsTagIdDeleteMutationError = AxiosError<HTTPValidationError>

/**
 * @summary Delete Tag
 */
export const useDeleteTagTagsTagIdDelete = <TError = AxiosError<HTTPValidationError>>(
  tagId: number, options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof deleteTagTagsTagIdDelete>>, TError, Key, Arguments, Awaited<ReturnType<typeof deleteTagTagsTagIdDelete>>> & { swrKey?: string }, axios?: AxiosRequestConfig}
) => {

  const {swr: swrOptions, axios: axiosOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getDeleteTagTagsTagIdDeleteMutationKey(tagId);
  const swrFn = getDeleteTagTagsTagIdDeleteMutationFetcher(tagId, axiosOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * Create a new comment for a post.
 * @summary Create Comment
 */
export const createCommentPostsPostIdCommentsPost = (
    postId: string,
    commentCreate: CommentCreate, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CommentRead>> => {
    return axios.default.post(
      `http://100.109.46.43:8007/posts/${postId}/comments`,
      commentCreate,options
    );
  }



export const getCreateCommentPostsPostIdCommentsPostMutationFetcher = (postId: string, options?: AxiosRequestConfig) => {
  return (_: Key, { arg }: { arg: CommentCreate }): Promise<AxiosResponse<CommentRead>> => {
    return createCommentPostsPostIdCommentsPost(postId, arg, options);
  }
}
export const getCreateCommentPostsPostIdCommentsPostMutationKey = (postId: string,) => [`http://100.109.46.43:8007/posts/${postId}/comments`] as const;

export type CreateCommentPostsPostIdCommentsPostMutationResult = NonNullable<Awaited<ReturnType<typeof createCommentPostsPostIdCommentsPost>>>
export type CreateCommentPostsPostIdCommentsPostMutationError = AxiosError<HTTPValidationError>

/**
 * @summary Create Comment
 */
export const useCreateCommentPostsPostIdCommentsPost = <TError = AxiosError<HTTPValidationError>>(
  postId: string, options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof createCommentPostsPostIdCommentsPost>>, TError, Key, CommentCreate, Awaited<ReturnType<typeof createCommentPostsPostIdCommentsPost>>> & { swrKey?: string }, axios?: AxiosRequestConfig}
) => {

  const {swr: swrOptions, axios: axiosOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getCreateCommentPostsPostIdCommentsPostMutationKey(postId);
  const swrFn = getCreateCommentPostsPostIdCommentsPostMutationFetcher(postId, axiosOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * List comments for a post.
 * @summary List Post Comments
 */
export const listPostCommentsPostsPostIdCommentsGet = (
    postId: string,
    params?: ListPostCommentsPostsPostIdCommentsGetParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CommentRead[]>> => {
    return axios.default.get(
      `http://100.109.46.43:8007/posts/${postId}/comments`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }



export const getListPostCommentsPostsPostIdCommentsGetKey = (postId: string,
    params?: ListPostCommentsPostsPostIdCommentsGetParams,) => [`http://100.109.46.43:8007/posts/${postId}/comments`, ...(params ? [params]: [])] as const;

export type ListPostCommentsPostsPostIdCommentsGetQueryResult = NonNullable<Awaited<ReturnType<typeof listPostCommentsPostsPostIdCommentsGet>>>
export type ListPostCommentsPostsPostIdCommentsGetQueryError = AxiosError<HTTPValidationError>

/**
 * @summary List Post Comments
 */
export const useListPostCommentsPostsPostIdCommentsGet = <TError = AxiosError<HTTPValidationError>>(
  postId: string,
    params?: ListPostCommentsPostsPostIdCommentsGetParams, options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof listPostCommentsPostsPostIdCommentsGet>>, TError> & { swrKey?: Key, enabled?: boolean }, axios?: AxiosRequestConfig }
) => {
  const {swr: swrOptions, axios: axiosOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false && !!(postId)
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getListPostCommentsPostsPostIdCommentsGetKey(postId,params) : null);
  const swrFn = () => listPostCommentsPostsPostIdCommentsGet(postId,params, axiosOptions)

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * Update comment (author only).
 * @summary Update Comment
 */
export const updateCommentCommentsCommentIdPut = (
    commentId: string,
    commentUpdate: CommentUpdate, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CommentRead>> => {
    return axios.default.put(
      `http://100.109.46.43:8007/comments/${commentId}`,
      commentUpdate,options
    );
  }



export const getUpdateCommentCommentsCommentIdPutMutationFetcher = (commentId: string, options?: AxiosRequestConfig) => {
  return (_: Key, { arg }: { arg: CommentUpdate }): Promise<AxiosResponse<CommentRead>> => {
    return updateCommentCommentsCommentIdPut(commentId, arg, options);
  }
}
export const getUpdateCommentCommentsCommentIdPutMutationKey = (commentId: string,) => [`http://100.109.46.43:8007/comments/${commentId}`] as const;

export type UpdateCommentCommentsCommentIdPutMutationResult = NonNullable<Awaited<ReturnType<typeof updateCommentCommentsCommentIdPut>>>
export type UpdateCommentCommentsCommentIdPutMutationError = AxiosError<HTTPValidationError>

/**
 * @summary Update Comment
 */
export const useUpdateCommentCommentsCommentIdPut = <TError = AxiosError<HTTPValidationError>>(
  commentId: string, options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof updateCommentCommentsCommentIdPut>>, TError, Key, CommentUpdate, Awaited<ReturnType<typeof updateCommentCommentsCommentIdPut>>> & { swrKey?: string }, axios?: AxiosRequestConfig}
) => {

  const {swr: swrOptions, axios: axiosOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getUpdateCommentCommentsCommentIdPutMutationKey(commentId);
  const swrFn = getUpdateCommentCommentsCommentIdPutMutationFetcher(commentId, axiosOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * Delete comment (author only).
 * @summary Delete Comment
 */
export const deleteCommentCommentsCommentIdDelete = (
    commentId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    return axios.default.delete(
      `http://100.109.46.43:8007/comments/${commentId}`,options
    );
  }



export const getDeleteCommentCommentsCommentIdDeleteMutationFetcher = (commentId: string, options?: AxiosRequestConfig) => {
  return (_: Key, __: { arg: Arguments }): Promise<AxiosResponse<unknown>> => {
    return deleteCommentCommentsCommentIdDelete(commentId, options);
  }
}
export const getDeleteCommentCommentsCommentIdDeleteMutationKey = (commentId: string,) => [`http://100.109.46.43:8007/comments/${commentId}`] as const;

export type DeleteCommentCommentsCommentIdDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof deleteCommentCommentsCommentIdDelete>>>
export type DeleteCommentCommentsCommentIdDeleteMutationError = AxiosError<HTTPValidationError>

/**
 * @summary Delete Comment
 */
export const useDeleteCommentCommentsCommentIdDelete = <TError = AxiosError<HTTPValidationError>>(
  commentId: string, options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof deleteCommentCommentsCommentIdDelete>>, TError, Key, Arguments, Awaited<ReturnType<typeof deleteCommentCommentsCommentIdDelete>>> & { swrKey?: string }, axios?: AxiosRequestConfig}
) => {

  const {swr: swrOptions, axios: axiosOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getDeleteCommentCommentsCommentIdDeleteMutationKey(commentId);
  const swrFn = getDeleteCommentCommentsCommentIdDeleteMutationFetcher(commentId, axiosOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * Like a post.
 * @summary Create Like
 */
export const createLikePostsPostIdLikesPost = (
    postId: string,
    likeCreate: LikeCreate, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<LikeRead>> => {
    return axios.default.post(
      `http://100.109.46.43:8007/posts/${postId}/likes`,
      likeCreate,options
    );
  }



export const getCreateLikePostsPostIdLikesPostMutationFetcher = (postId: string, options?: AxiosRequestConfig) => {
  return (_: Key, { arg }: { arg: LikeCreate }): Promise<AxiosResponse<LikeRead>> => {
    return createLikePostsPostIdLikesPost(postId, arg, options);
  }
}
export const getCreateLikePostsPostIdLikesPostMutationKey = (postId: string,) => [`http://100.109.46.43:8007/posts/${postId}/likes`] as const;

export type CreateLikePostsPostIdLikesPostMutationResult = NonNullable<Awaited<ReturnType<typeof createLikePostsPostIdLikesPost>>>
export type CreateLikePostsPostIdLikesPostMutationError = AxiosError<HTTPValidationError>

/**
 * @summary Create Like
 */
export const useCreateLikePostsPostIdLikesPost = <TError = AxiosError<HTTPValidationError>>(
  postId: string, options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof createLikePostsPostIdLikesPost>>, TError, Key, LikeCreate, Awaited<ReturnType<typeof createLikePostsPostIdLikesPost>>> & { swrKey?: string }, axios?: AxiosRequestConfig}
) => {

  const {swr: swrOptions, axios: axiosOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getCreateLikePostsPostIdLikesPostMutationKey(postId);
  const swrFn = getCreateLikePostsPostIdLikesPostMutationFetcher(postId, axiosOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * Unlike a post.
 * @summary Delete Like
 */
export const deleteLikePostsPostIdLikesDelete = (
    postId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    return axios.default.delete(
      `http://100.109.46.43:8007/posts/${postId}/likes`,options
    );
  }



export const getDeleteLikePostsPostIdLikesDeleteMutationFetcher = (postId: string, options?: AxiosRequestConfig) => {
  return (_: Key, __: { arg: Arguments }): Promise<AxiosResponse<unknown>> => {
    return deleteLikePostsPostIdLikesDelete(postId, options);
  }
}
export const getDeleteLikePostsPostIdLikesDeleteMutationKey = (postId: string,) => [`http://100.109.46.43:8007/posts/${postId}/likes`] as const;

export type DeleteLikePostsPostIdLikesDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof deleteLikePostsPostIdLikesDelete>>>
export type DeleteLikePostsPostIdLikesDeleteMutationError = AxiosError<HTTPValidationError>

/**
 * @summary Delete Like
 */
export const useDeleteLikePostsPostIdLikesDelete = <TError = AxiosError<HTTPValidationError>>(
  postId: string, options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof deleteLikePostsPostIdLikesDelete>>, TError, Key, Arguments, Awaited<ReturnType<typeof deleteLikePostsPostIdLikesDelete>>> & { swrKey?: string }, axios?: AxiosRequestConfig}
) => {

  const {swr: swrOptions, axios: axiosOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getDeleteLikePostsPostIdLikesDeleteMutationKey(postId);
  const swrFn = getDeleteLikePostsPostIdLikesDeleteMutationFetcher(postId, axiosOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * List who liked a post.
 * @summary List Post Likes
 */
export const listPostLikesPostsPostIdLikesGet = (
    postId: string,
    params?: ListPostLikesPostsPostIdLikesGetParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<LikeRead[]>> => {
    return axios.default.get(
      `http://100.109.46.43:8007/posts/${postId}/likes`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }



export const getListPostLikesPostsPostIdLikesGetKey = (postId: string,
    params?: ListPostLikesPostsPostIdLikesGetParams,) => [`http://100.109.46.43:8007/posts/${postId}/likes`, ...(params ? [params]: [])] as const;

export type ListPostLikesPostsPostIdLikesGetQueryResult = NonNullable<Awaited<ReturnType<typeof listPostLikesPostsPostIdLikesGet>>>
export type ListPostLikesPostsPostIdLikesGetQueryError = AxiosError<HTTPValidationError>

/**
 * @summary List Post Likes
 */
export const useListPostLikesPostsPostIdLikesGet = <TError = AxiosError<HTTPValidationError>>(
  postId: string,
    params?: ListPostLikesPostsPostIdLikesGetParams, options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof listPostLikesPostsPostIdLikesGet>>, TError> & { swrKey?: Key, enabled?: boolean }, axios?: AxiosRequestConfig }
) => {
  const {swr: swrOptions, axios: axiosOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false && !!(postId)
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getListPostLikesPostsPostIdLikesGetKey(postId,params) : null);
  const swrFn = () => listPostLikesPostsPostIdLikesGet(postId,params, axiosOptions)

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * List all available themes.

Returns all themes with their configuration and status.
 * @summary List Themes
 */
export const listThemesThemesGet = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ThemeRead[]>> => {
    return axios.default.get(
      `http://100.109.46.43:8007/themes`,options
    );
  }



export const getListThemesThemesGetKey = () => [`http://100.109.46.43:8007/themes`] as const;

export type ListThemesThemesGetQueryResult = NonNullable<Awaited<ReturnType<typeof listThemesThemesGet>>>
export type ListThemesThemesGetQueryError = AxiosError<unknown>

/**
 * @summary List Themes
 */
export const useListThemesThemesGet = <TError = AxiosError<unknown>>(
   options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof listThemesThemesGet>>, TError> & { swrKey?: Key, enabled?: boolean }, axios?: AxiosRequestConfig }
) => {
  const {swr: swrOptions, axios: axiosOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getListThemesThemesGetKey() : null);
  const swrFn = () => listThemesThemesGet(axiosOptions)

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * Activate a theme.

Deactivates all other themes and activates the specified one.
Requires authentication and appropriate permissions.
 * @summary Activate Theme
 */
export const activateThemeThemesThemeIdActivatePut = (
    themeId: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ThemeRead>> => {
    return axios.default.put(
      `http://100.109.46.43:8007/themes/${themeId}/activate`,undefined,options
    );
  }



export const getActivateThemeThemesThemeIdActivatePutMutationFetcher = (themeId: number, options?: AxiosRequestConfig) => {
  return (_: Key, __: { arg: Arguments }): Promise<AxiosResponse<ThemeRead>> => {
    return activateThemeThemesThemeIdActivatePut(themeId, options);
  }
}
export const getActivateThemeThemesThemeIdActivatePutMutationKey = (themeId: number,) => [`http://100.109.46.43:8007/themes/${themeId}/activate`] as const;

export type ActivateThemeThemesThemeIdActivatePutMutationResult = NonNullable<Awaited<ReturnType<typeof activateThemeThemesThemeIdActivatePut>>>
export type ActivateThemeThemesThemeIdActivatePutMutationError = AxiosError<HTTPValidationError>

/**
 * @summary Activate Theme
 */
export const useActivateThemeThemesThemeIdActivatePut = <TError = AxiosError<HTTPValidationError>>(
  themeId: number, options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof activateThemeThemesThemeIdActivatePut>>, TError, Key, Arguments, Awaited<ReturnType<typeof activateThemeThemesThemeIdActivatePut>>> & { swrKey?: string }, axios?: AxiosRequestConfig}
) => {

  const {swr: swrOptions, axios: axiosOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getActivateThemeThemesThemeIdActivatePutMutationKey(themeId);
  const swrFn = getActivateThemeThemesThemeIdActivatePutMutationFetcher(themeId, axiosOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * Get the currently active theme.

Returns the active theme configuration.
 * @summary Get Active Theme
 */
export const getActiveThemeThemesActiveGet = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ThemeRead>> => {
    return axios.default.get(
      `http://100.109.46.43:8007/themes/active`,options
    );
  }



export const getGetActiveThemeThemesActiveGetKey = () => [`http://100.109.46.43:8007/themes/active`] as const;

export type GetActiveThemeThemesActiveGetQueryResult = NonNullable<Awaited<ReturnType<typeof getActiveThemeThemesActiveGet>>>
export type GetActiveThemeThemesActiveGetQueryError = AxiosError<unknown>

/**
 * @summary Get Active Theme
 */
export const useGetActiveThemeThemesActiveGet = <TError = AxiosError<unknown>>(
   options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof getActiveThemeThemesActiveGet>>, TError> & { swrKey?: Key, enabled?: boolean }, axios?: AxiosRequestConfig }
) => {
  const {swr: swrOptions, axios: axiosOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getGetActiveThemeThemesActiveGetKey() : null);
  const swrFn = () => getActiveThemeThemesActiveGet(axiosOptions)

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * Upload single or multiple files.

Files are stored in the media directory configured via MEDIA_DIR env variable.
Supports associating files with a specific post.
 * @summary Upload Files
 */
export const uploadFilesUploadPost = (
    bodyUploadFilesUploadPost: BodyUploadFilesUploadPost, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PostFileRead[]>> => {const formData = new FormData();
bodyUploadFilesUploadPost.files.forEach(value => formData.append(`files`, value));
if(bodyUploadFilesUploadPost.post_id !== undefined && bodyUploadFilesUploadPost.post_id !== null) {
 formData.append(`post_id`, bodyUploadFilesUploadPost.post_id)
 }

    return axios.default.post(
      `http://100.109.46.43:8007/upload`,
      formData,options
    );
  }



export const getUploadFilesUploadPostMutationFetcher = ( options?: AxiosRequestConfig) => {
  return (_: Key, { arg }: { arg: BodyUploadFilesUploadPost }): Promise<AxiosResponse<PostFileRead[]>> => {
    return uploadFilesUploadPost(arg, options);
  }
}
export const getUploadFilesUploadPostMutationKey = () => [`http://100.109.46.43:8007/upload`] as const;

export type UploadFilesUploadPostMutationResult = NonNullable<Awaited<ReturnType<typeof uploadFilesUploadPost>>>
export type UploadFilesUploadPostMutationError = AxiosError<HTTPValidationError>

/**
 * @summary Upload Files
 */
export const useUploadFilesUploadPost = <TError = AxiosError<HTTPValidationError>>(
   options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof uploadFilesUploadPost>>, TError, Key, BodyUploadFilesUploadPost, Awaited<ReturnType<typeof uploadFilesUploadPost>>> & { swrKey?: string }, axios?: AxiosRequestConfig}
) => {

  const {swr: swrOptions, axios: axiosOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getUploadFilesUploadPostMutationKey();
  const swrFn = getUploadFilesUploadPostMutationFetcher(axiosOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * List uploaded files.

Can be filtered by post ID. Supports pagination.
 * @summary List Files
 */
export const listFilesUploadGet = (
    params?: ListFilesUploadGetParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PostFileRead[]>> => {
    return axios.default.get(
      `http://100.109.46.43:8007/upload`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }



export const getListFilesUploadGetKey = (params?: ListFilesUploadGetParams,) => [`http://100.109.46.43:8007/upload`, ...(params ? [params]: [])] as const;

export type ListFilesUploadGetQueryResult = NonNullable<Awaited<ReturnType<typeof listFilesUploadGet>>>
export type ListFilesUploadGetQueryError = AxiosError<HTTPValidationError>

/**
 * @summary List Files
 */
export const useListFilesUploadGet = <TError = AxiosError<HTTPValidationError>>(
  params?: ListFilesUploadGetParams, options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof listFilesUploadGet>>, TError> & { swrKey?: Key, enabled?: boolean }, axios?: AxiosRequestConfig }
) => {
  const {swr: swrOptions, axios: axiosOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getListFilesUploadGetKey(params) : null);
  const swrFn = () => listFilesUploadGet(params, axiosOptions)

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * Delete an uploaded file.

Removes both the database record and the physical file.
Only the file owner or users with appropriate permissions can delete files.
 * @summary Delete File
 */
export const deleteFileUploadFileIdDelete = (
    fileId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<null>> => {
    return axios.default.delete(
      `http://100.109.46.43:8007/upload/${fileId}`,options
    );
  }



export const getDeleteFileUploadFileIdDeleteMutationFetcher = (fileId: string, options?: AxiosRequestConfig) => {
  return (_: Key, __: { arg: Arguments }): Promise<AxiosResponse<null>> => {
    return deleteFileUploadFileIdDelete(fileId, options);
  }
}
export const getDeleteFileUploadFileIdDeleteMutationKey = (fileId: string,) => [`http://100.109.46.43:8007/upload/${fileId}`] as const;

export type DeleteFileUploadFileIdDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof deleteFileUploadFileIdDelete>>>
export type DeleteFileUploadFileIdDeleteMutationError = AxiosError<HTTPValidationError>

/**
 * @summary Delete File
 */
export const useDeleteFileUploadFileIdDelete = <TError = AxiosError<HTTPValidationError>>(
  fileId: string, options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof deleteFileUploadFileIdDelete>>, TError, Key, Arguments, Awaited<ReturnType<typeof deleteFileUploadFileIdDelete>>> & { swrKey?: string }, axios?: AxiosRequestConfig}
) => {

  const {swr: swrOptions, axios: axiosOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getDeleteFileUploadFileIdDeleteMutationKey(fileId);
  const swrFn = getDeleteFileUploadFileIdDeleteMutationFetcher(fileId, axiosOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * Get file metadata.

Returns file information without serving the actual file content.
 * @summary Get File Metadata
 */
export const getFileMetadataUploadFileIdGet = (
    fileId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PostFileRead>> => {
    return axios.default.get(
      `http://100.109.46.43:8007/upload/${fileId}`,options
    );
  }



export const getGetFileMetadataUploadFileIdGetKey = (fileId: string,) => [`http://100.109.46.43:8007/upload/${fileId}`] as const;

export type GetFileMetadataUploadFileIdGetQueryResult = NonNullable<Awaited<ReturnType<typeof getFileMetadataUploadFileIdGet>>>
export type GetFileMetadataUploadFileIdGetQueryError = AxiosError<HTTPValidationError>

/**
 * @summary Get File Metadata
 */
export const useGetFileMetadataUploadFileIdGet = <TError = AxiosError<HTTPValidationError>>(
  fileId: string, options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof getFileMetadataUploadFileIdGet>>, TError> & { swrKey?: Key, enabled?: boolean }, axios?: AxiosRequestConfig }
) => {
  const {swr: swrOptions, axios: axiosOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false && !!(fileId)
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getGetFileMetadataUploadFileIdGetKey(fileId) : null);
  const swrFn = () => getFileMetadataUploadFileIdGet(fileId, axiosOptions)

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * Download the actual file.

Serves the file content with appropriate headers.
 * @summary Download File
 */
export const downloadFileUploadFileIdDownloadGet = (
    fileId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    return axios.default.get(
      `http://100.109.46.43:8007/upload/${fileId}/download`,options
    );
  }



export const getDownloadFileUploadFileIdDownloadGetKey = (fileId: string,) => [`http://100.109.46.43:8007/upload/${fileId}/download`] as const;

export type DownloadFileUploadFileIdDownloadGetQueryResult = NonNullable<Awaited<ReturnType<typeof downloadFileUploadFileIdDownloadGet>>>
export type DownloadFileUploadFileIdDownloadGetQueryError = AxiosError<HTTPValidationError>

/**
 * @summary Download File
 */
export const useDownloadFileUploadFileIdDownloadGet = <TError = AxiosError<HTTPValidationError>>(
  fileId: string, options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof downloadFileUploadFileIdDownloadGet>>, TError> & { swrKey?: Key, enabled?: boolean }, axios?: AxiosRequestConfig }
) => {
  const {swr: swrOptions, axios: axiosOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false && !!(fileId)
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getDownloadFileUploadFileIdDownloadGetKey(fileId) : null);
  const swrFn = () => downloadFileUploadFileIdDownloadGet(fileId, axiosOptions)

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * @summary Health Check
 */
export const healthCheckHealthGet = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    return axios.default.get(
      `http://100.109.46.43:8007/health`,options
    );
  }



export const getHealthCheckHealthGetKey = () => [`http://100.109.46.43:8007/health`] as const;

export type HealthCheckHealthGetQueryResult = NonNullable<Awaited<ReturnType<typeof healthCheckHealthGet>>>
export type HealthCheckHealthGetQueryError = AxiosError<unknown>

/**
 * @summary Health Check
 */
export const useHealthCheckHealthGet = <TError = AxiosError<unknown>>(
   options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof healthCheckHealthGet>>, TError> & { swrKey?: Key, enabled?: boolean }, axios?: AxiosRequestConfig }
) => {
  const {swr: swrOptions, axios: axiosOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getHealthCheckHealthGetKey() : null);
  const swrFn = () => healthCheckHealthGet(axiosOptions)

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * @summary Root
 */
export const rootGet = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    return axios.default.get(
      `http://100.109.46.43:8007/`,options
    );
  }



export const getRootGetKey = () => [`http://100.109.46.43:8007/`] as const;

export type RootGetQueryResult = NonNullable<Awaited<ReturnType<typeof rootGet>>>
export type RootGetQueryError = AxiosError<unknown>

/**
 * @summary Root
 */
export const useRootGet = <TError = AxiosError<unknown>>(
   options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof rootGet>>, TError> & { swrKey?: Key, enabled?: boolean }, axios?: AxiosRequestConfig }
) => {
  const {swr: swrOptions, axios: axiosOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getRootGetKey() : null);
  const swrFn = () => rootGet(axiosOptions)

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}
